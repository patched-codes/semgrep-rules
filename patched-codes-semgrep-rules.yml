# Patched Semgrep Rules
# Source Repo: https://github.com/patched-codes/semgrep-rules
# License: MIT
# Version: 0.0.1
---
rules:
- id: python_flask_rule-app-debug
  languages:
  - python
  message: 'The Flask application is running with `debug=True` configured. By enabling
    this option, certain

    exceptions or errors could cause sensitive information to be leaked in HTTP responses.


    Additionally, it is not recommended to run a Flask application using `Flask.run(...)`
    in

    production. Instead, a WSGI server such as

    [gunicorn](https://flask.palletsprojects.com/en/2.3.x/deploying/gunicorn/)

    or [waitress](https://flask.palletsprojects.com/en/2.3.x/deploying/waitress/)
    be used instead.


    For more information on deployment options for Flask applications see:

    - https://flask.palletsprojects.com/en/2.3.x/deploying/

    '
  metadata:
    category: security
    cwe: CWE-489
    owasp:
    - A6:2017-Security Misconfiguration
    - A05:2021-Security Misconfiguration
    security-severity: Medium
    shortDescription: Active debug code
  patterns:
  - pattern-inside: 'import flask

      ...

      '
  - pattern: $APP.run(..., debug=True, ...)
  severity: WARNING
- id: python_ftp_rule-ftplib
  languages:
  - python
  message: "The application was found using an FTP library. As FTP does not provide\
    \ encryption, it is\nstrongly recommended that any file transfers be done over\
    \ a more secure transport such as\nSSH.\n\nThe [paramiko](https://www.paramiko.org/)\
    \ library can be used with an SCP module to allow\nsecure file transfers.\n\n\
    Example using `paramiko` SSH client and the `scp` module:\n```\nimport paramiko\n\
    import scp\n\n# Create an SSH client\nwith paramiko.SSHClient() as ssh:\n    #\
    \ Load the system host keys so we can confirm the\n    # host we are connecting\
    \ to is legitimate\n    ssh.load_system_host_keys('/home/appuser/.ssh/known_hosts')\n\
    \n    # Connect to the remote host using our SSH private key\n    ssh.connect(hostname='example.org',\n\
    \                port=22,\n                username='appuser',\n             \
    \   key_filename='/home/appuser/.ssh/private_key')\n\n    # Create an SCP client\
    \ with the ssh transport and copy files\n    with scp.SCPClient(ssh.get_transport())\
    \ as secure_copy:\n        secure_copy.get('remote/test.file', 'local/test.file')\n\
    \        secure_copy.put('local/some.file', 'remote/some.file')\n```\n\nFor more\
    \ information on the paramiko module see:\n- https://www.paramiko.org/\n\nFor\
    \ more information on the scp module see:\n- https://github.com/jbardin/scp.py\n"
  metadata:
    category: security
    cwe: CWE-319
    owasp:
    - A3:2017-Sensitive Data Exposure
    - A02:2021-Cryptographic Failures
    security-severity: Medium
    shortDescription: Cleartext transmission of sensitive information
  pattern: ftplib.$ANYTHING(...)
  severity: WARNING
- id: python_crypto_rule-crypto-cipher-des
  languages:
  - python
  message: 'DES, TripleDES, RC2 and RC4 are all considered broken or insecure cryptographic
    algorithms.

    Newer algorithms apply message integrity to validate ciphertext has not been tampered

    with. Consider using `ChaCha20Poly1305` instead as it is easier and faster than
    the

    alternatives such as `AES-256-GCM`.


    For older applications that don''t have support for `ChaCha20Poly1305`,

    `AES-256-GCM` is recommended, however it has many drawbacks:

    - Slower than `ChaCha20Poly1305`.

    - Catastrophic failure if nonce values are reused.


    Note that the `Crypto` and `Cryptodome` Python packages are no longer recommended
    for

    new applications, instead consider using the [cryptography](https://cryptography.io/)
    package.


    Example using `ChaCha20Poly1305`:

    ```

    import os

    # Import ChaCha20Poly1305 from cryptography

    from cryptography.hazmat.primitives.ciphers.aead import ChaCha20Poly1305

    # Our plaintext to encrypt

    plain_text = b"Secret text to encrypt"

    # We do not require authenticated but unencrypted data, so set to None

    aad = None

    # Generate a secure key

    key = ChaCha20Poly1305.generate_key()

    # Create a new ChaCha20Poly1305 instance with our secure key

    chacha = ChaCha20Poly1305(key)

    # Note: nonce values _must_ be regenerated every time they are used.

    nonce = os.urandom(12)

    # Encrypt our plaintext

    cipher_text = chacha.encrypt(nonce, plain_text, aad)

    # Decrypt the plain text using the nonce and cipher_text

    chacha.decrypt(nonce, cipher_text, aad)

    ```


    Example using `AESGCM`:

    ```

    import os

    # Import AESGCM from cryptography

    from cryptography.hazmat.primitives.ciphers.aead import AESGCM

    # Our plaintext to encrypt

    plain_text = b"Secret text to encrypt"

    # We do not require authenticated but unencrypted data, so set to None

    aad = None

    # Generate a secure key

    key = AESGCM.generate_key(bit_length=128)

    # Create a new AESGCM instance with our secure key

    aesgcm = AESGCM(key)

    # Note: nonce values _must_ be regenerated every time they are used.

    nonce = os.urandom(12)

    # Encrypt our plaintext

    cipher_text = aesgcm.encrypt(nonce, plain_text, aad)

    # Decrypt the plain text using the nonce and cipher_text

    aesgcm.decrypt(nonce, cipher_text, aad)

    ```


    For more information on the cryptography module see:

    - https://cryptography.io/en/latest/

    '
  metadata:
    category: security
    cwe: CWE-327
    owasp:
    - A3:2017-Sensitive Data Exposure
    - A02:2021-Cryptographic Failures
    security-severity: Medium
    shortDescription: Use of a broken or risky cryptographic algorithm
  patterns:
  - pattern-either:
    - pattern: Cryptodome.Cipher.DES.new(...)
    - pattern: Crypto.Cipher.DES.new(...)
  severity: WARNING
- id: python_crypto_rule-crypto.hazmat-hash-sha1
  languages:
  - python
  message: 'The application was found using an insecure or risky digest or signature
    algorithm. MD2, MD5

    and SHA1 hash algorithms have been found to be vulnerable to producing collisions.


    This means

    that two different values, when hashed, can lead to the same hash value. If the
    application is

    trying

    to use these hash methods for storing passwords, then it is recommended to switch
    to a

    password hashing

    algorithm such as Argon2id or PBKDF2.

    It is strongly recommended that a standard digest algorithm be chosen instead
    as implementing

    a custom algorithm is prone to error.


    Example of creating a SHA-384 hash using the `cryptography` package:

    ```

    from cryptography.hazmat.primitives import hashes

    # Create a SHA384 digest

    digest = hashes.Hash(hashes.SHA384())

    # Update the digest with some initial data

    digest.update(b"some data to hash")

    # Add more data to the digest

    digest.update(b"some more data")

    # Finalize the digest as bytes

    result = digest.finalize()

    ```


    For more information on secure password storage see OWASP:

    - https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html


    For more information on the cryptography module see:

    - https://cryptography.io/en/latest/

    '
  metadata:
    category: security
    cwe: CWE-327
    owasp:
    - A3:2017-Sensitive Data Exposure
    - A02:2021-Cryptographic Failures
    security-severity: Medium
    shortDescription: Use of a broken or risky cryptographic algorithm
  pattern: cryptography.hazmat.primitives.hashes.SHA1(...)
  severity: WARNING
- id: python_crypto_rule-hash-sha1
  languages:
  - python
  message: "The application was found using an insecure or risky digest or signature\
    \ algorithm. MD2, MD4,\n MD5  and SHA1 hash algorithms have been found to be vulnerable\
    \ to producing collisions.\n\nThis means\nthat two different values, when hashed,\
    \ can lead to the same hash value. If the application is\ntrying\nto use these\
    \ hash methods for storing passwords, then it is recommended to switch to a\n\
    password hashing\nalgorithm such as Argon2id or PBKDF2.\n\nNote that the `Crypto`\
    \ and `Cryptodome` Python packages are no longer recommended for\nnew applications,\
    \ instead consider using the [cryptography](https://cryptography.io/) package.\n\
    \nExample of creating a SHA-384 hash using the `cryptography` package:\n```\n\
    from cryptography.hazmat.primitives import hashes\n# Create a SHA384 digest\n\
    digest = hashes.Hash(hashes.SHA384())\n# Update the digest with some initial data\n\
    digest.update(b\"some data to hash\")\n# Add more data to the digest\ndigest.update(b\"\
    some more data\")\n# Finalize the digest as bytes\nresult = digest.finalize()\n\
    ```\n\nFor more information on secure password storage see OWASP:\n- https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html\n\
    \nFor more information on the cryptography module see:\n- https://cryptography.io/en/latest/\n"
  metadata:
    category: security
    cwe: CWE-327
    owasp:
    - A3:2017-Sensitive Data Exposure
    - A02:2021-Cryptographic Failures
    security-severity: Medium
    shortDescription: Use of a broken or risky cryptographic algorithm
  pattern: hashlib.sha1(...)
  severity: WARNING
- id: python_crypto_rule-crypto-encrypt-dsa-rsa
  languages:
  - python
  message: "The application is generating an RSA key that is less than the recommended\
    \ 2048 bits.\nThe National Institute of Standards and Technology (NIST) deprecated\
    \ signing Digital\nCertificates that contained RSA Public Keys of 1024 bits in\
    \ December 2010. While\n1024-bit RSA keys have not been factored yet, advances\
    \ in compute may make it possible\nin the near future.\n\nConsider upgrading to\
    \ the newer asymmetric algorithm such as `X25519` which handles\nthe complexities\
    \ of generating key pairs and choosing correct key sizes for you:\n```\nfrom cryptography.hazmat.primitives.asymmetric.x25519\
    \ import X25519PrivateKey\n\n# Generate a private key for use in the exchange.\n\
    private_key = X25519PrivateKey.generate()\n# Work with private key/exchange with\
    \ a peer's\n# public key to created a shared and derived key\n# ...\n```\n\nOtherwise\
    \ use a key size greater than 2048 when generating RSA keys:\n```\nfrom cryptography.hazmat.primitives.asymmetric\
    \ import rsa\n# Generate a private key of 4096 bits\nprivate_key = rsa.generate_private_key(\n\
    \    # do not change the exponent value from 65537\n    public_exponent=65537,\n\
    \    key_size=4096,\n)\n# Work with the private key to sign/encrypt data\n# ...\n\
    ```\n\nFor more information on using the cryptography module see:\n- https://cryptography.io/en/latest\n"
  metadata:
    category: security
    cwe: CWE-326
    owasp:
    - A3:2017-Sensitive Data Exposure
    - A02:2021-Cryptographic Failures
    security-severity: Medium
    shortDescription: Inadequate encryption strength
  patterns:
  - pattern-either:
    - pattern: 'cryptography.hazmat.primitives.asymmetric.rsa.generate_private_key(...,key_size=$SIZE,...)

        '
    - pattern: 'cryptography.hazmat.primitives.asymmetric.rsa.generate_private_key($EXP,
        $SIZE,...)

        '
    - pattern: 'cryptography.hazmat.primitives.asymmetric.rsa.generate_private_key($SIZE,
        ...)

        '
    - pattern: 'cryptography.hazmat.primitives.asymmetric.dsa.generate_private_key(...,key_size=$SIZE,...)

        '
    - pattern: 'cryptography.hazmat.primitives.asymmetric.dsa.generate_private_key($EXP,
        $SIZE, ...)

        '
    - pattern: cryptography.hazmat.primitives.asymmetric.dsa.generate_private_key($SIZE,...)
    - pattern: Crypto.PublicKey.RSA.generate($SIZE, ...)
    - pattern: Crypto.PublicKey.DSA.generate($SIZE, ...)
    - pattern: Cryptodome.PublicKey.DSA.generate($SIZE, ...)
    - pattern: Cryptodome.PublicKey.RSA.generate($SIZE, ...)
    - pattern: Crypto.PublicKey.DSA.generate(bits=$SIZE, ...)
    - pattern: Cryptodome.PublicKey.DSA.generate(bits=$SIZE, ...)
    - pattern: pycrypto_rsa.generate(bits=$SIZE, ...)
    - pattern: pycrypto_dsa.generate(bits=$SIZE, ...)
    - pattern: pycryptodomex_rsa.generate(bits=$SIZE, ...)
    - pattern: pycryptodomex_rsa.generate($SIZE, ...)
    - pattern: pycryptodomex_dsa.generate(bits=$SIZE, ...)
    - pattern: pycryptodomex_dsa.generate($SIZE, ...)
  - metavariable-comparison:
      comparison: $SIZE < 2048
      metavariable: $SIZE
  severity: ERROR
- id: python_crypto_rule-crypto-cipher-blowfish
  languages:
  - python
  message: "The Blowfish encryption algorithm was meant as a drop-in replacement for\
    \ DES and was created in\n1993. Smaller key sizes may make the ciphertext vulnerable\
    \ to [birthday\nattacks](https://en.wikipedia.org/wiki/Birthday_attack). While\
    \ no known attacks against\nBlowfish\nexist, it should never be used to encrypt\
    \ files over 4GB in size. If possible consider\nusing ChaCha20Poly1305 or AES-GCM\
    \ instead of Blowfish.\n\nFor older applications that don't have support for `ChaCha20Poly1305`,\
    \ `AES-256-GCM` is\nrecommended, however it has many drawbacks:\n  - Slower than\
    \ `ChaCha20Poly1305`.\n  - Catastrophic failure if nonce values are reused.\n\n\
    Note that the `Crypto` and `Cryptodome` Python packages are no longer recommended\
    \ for\nnew applications, instead consider using the [cryptography](https://cryptography.io/)\
    \ package.\n\nExample using `ChaCha20Poly1305`:\n```\nimport os\n# Import ChaCha20Poly1305\
    \ from cryptography\nfrom cryptography.hazmat.primitives.ciphers.aead import ChaCha20Poly1305\n\
    # Our plaintext to encrypt\nplain_text = b\"Secret text to encrypt\"\n# We do\
    \ not require authenticated but unencrypted data, so set to None\naad = None\n\
    # Generate a secure key\nkey = ChaCha20Poly1305.generate_key()\n# Create a new\
    \ ChaCha20Poly1305 instance with our secure key\nchacha = ChaCha20Poly1305(key)\n\
    # Note: nonce values _must_ be regenerated every time they are used.\nnonce =\
    \ os.urandom(12)\n# Encrypt our plaintext\ncipher_text = chacha.encrypt(nonce,\
    \ plain_text, aad)\n# Decrypt the plain text using the nonce and cipher_text\n\
    chacha.decrypt(nonce, cipher_text, aad)\n```\n\nExample using `AESGCM`:\n```\n\
    import os\n# Import AESGCM from cryptography\nfrom cryptography.hazmat.primitives.ciphers.aead\
    \ import AESGCM\n# Our plaintext to encrypt\nplain_text = b\"Secret text to encrypt\"\
    \n# We do not require authenticated but unencrypted data, so set to None\naad\
    \ = None\n# Generate a secure key\nkey = AESGCM.generate_key(bit_length=128)\n\
    # Create a new AESGCM instance with our secure key\naesgcm = AESGCM(key)\n# Note:\
    \ nonce values _must_ be regenerated every time they are used.\nnonce = os.urandom(12)\n\
    # Encrypt our plaintext\ncipher_text = aesgcm.encrypt(nonce, plain_text, aad)\n\
    # Decrypt the plain text using the nonce and cipher_text\naesgcm.decrypt(nonce,\
    \ cipher_text, aad)\n```\n\nFor more information on the cryptography module see:\n\
    - https://cryptography.io/en/latest/\n"
  metadata:
    category: security
    cwe: CWE-327
    owasp:
    - A3:2017-Sensitive Data Exposure
    - A02:2021-Cryptographic Failures
    security-severity: Medium
    shortDescription: Use of a broken or risky cryptographic algorithm
  patterns:
  - pattern-either:
    - pattern: Cryptodome.Cipher.Blowfish.new(...)
    - pattern: Crypto.Cipher.Blowfish.new(...)
  severity: WARNING
- id: python_crypto_rule-crypto-hazmat-cipher-idea
  languages:
  - python
  message: "The IDEA encryption algorithm was meant as a drop-in replacement for DES\
    \ and was created in\n1991. A number of [vulnerabilities and\nexploits](https://en.wikipedia.org/wiki/International_Data_Encryption_Algorithm#Security)\
    \ have\nbeen identified to work against IDEA and\nit is no longer recommended.\
    \ If possible consider\nusing ChaCha20Poly1305 or AES-GCM instead of Blowfish.\n\
    \nFor older applications that don't have support for `ChaCha20Poly1305`, `AES-256-GCM`\
    \ is\nrecommended, however it has many drawbacks:\n  - Slower than `ChaCha20Poly1305`.\n\
    \  - Catastrophic failure if nonce values are reused.\n\nExample using `ChaCha20Poly1305`:\n\
    ```\nimport os\n# Import ChaCha20Poly1305 from cryptography\nfrom cryptography.hazmat.primitives.ciphers.aead\
    \ import ChaCha20Poly1305\n# Our plaintext to encrypt\nplain_text = b\"Secret\
    \ text to encrypt\"\n# We do not require authenticated but unencrypted data, so\
    \ set to None\naad = None\n# Generate a secure key\nkey = ChaCha20Poly1305.generate_key()\n\
    # Create a new ChaCha20Poly1305 instance with our secure key\nchacha = ChaCha20Poly1305(key)\n\
    # Note: nonce values _must_ be regenerated every time they are used.\nnonce =\
    \ os.urandom(12)\n# Encrypt our plaintext\ncipher_text = chacha.encrypt(nonce,\
    \ plain_text, aad)\n# Decrypt the plain text using the nonce and cipher_text\n\
    chacha.decrypt(nonce, cipher_text, aad)\n```\n\nExample using `AESGCM`:\n```\n\
    import os\n# Import AESGCM from cryptography\nfrom cryptography.hazmat.primitives.ciphers.aead\
    \ import AESGCM\n# Our plaintext to encrypt\nplain_text = b\"Secret text to encrypt\"\
    \n# We do not require authenticated but unencrypted data, so set to None\naad\
    \ = None\n# Generate a secure key\nkey = AESGCM.generate_key(bit_length=128)\n\
    # Create a new AESGCM instance with our secure key\naesgcm = AESGCM(key)\n# Note:\
    \ nonce values _must_ be regenerated every time they are used.\nnonce = os.urandom(12)\n\
    # Encrypt our plaintext\ncipher_text = aesgcm.encrypt(nonce, plain_text, aad)\n\
    # Decrypt the plain text using the nonce and cipher_text\naesgcm.decrypt(nonce,\
    \ cipher_text, aad)\n```\n\nFor more information on the cryptography module see:\n\
    - https://cryptography.io/en/latest/\n"
  metadata:
    category: security
    cwe: CWE-327
    owasp:
    - A3:2017-Sensitive Data Exposure
    - A02:2021-Cryptographic Failures
    security-severity: Medium
    shortDescription: Use of a Broken or Risky Cryptographic Algorithm
  pattern: cryptography.hazmat.primitives.ciphers.algorithms.IDEA(...)
  severity: WARNING
- id: python_crypto_rule-crypto-cipher-xor
  languages:
  - python
  message: 'The application was found using the `xor` algorithm, which can be trivially
    decoded.

    Newer algorithms apply message integrity to validate ciphertext has not been tampered

    with. Consider using `ChaCha20Poly1305` instead as it is easier and faster than
    the

    alternatives such as `AES-256-GCM`.


    For older applications that don''t have support for `ChaCha20Poly1305`,

    `AES-256-GCM` is recommended, however it has many drawbacks:

    - Slower than `ChaCha20Poly1305`.

    - Catastrophic failure if nonce values are reused.


    Note that the `Crypto` and `Cryptodome` Python packages are no longer recommended
    for

    new applications, instead consider using the [cryptography](https://cryptography.io/)
    package.


    Example using `ChaCha20Poly1305`:

    ```

    import os

    # Import ChaCha20Poly1305 from cryptography

    from cryptography.hazmat.primitives.ciphers.aead import ChaCha20Poly1305

    # Our plaintext to encrypt

    plain_text = b"Secret text to encrypt"

    # We do not require authenticated but unencrypted data, so set to None

    aad = None

    # Generate a secure key

    key = ChaCha20Poly1305.generate_key()

    # Create a new ChaCha20Poly1305 instance with our secure key

    chacha = ChaCha20Poly1305(key)

    # Note: nonce values _must_ be regenerated every time they are used.

    nonce = os.urandom(12)

    # Encrypt our plaintext

    cipher_text = chacha.encrypt(nonce, plain_text, aad)

    # Decrypt the plain text using the nonce and cipher_text

    chacha.decrypt(nonce, cipher_text, aad)

    ```


    Example using `AESGCM`:

    ```

    import os

    # Import AESGCM from cryptography

    from cryptography.hazmat.primitives.ciphers.aead import AESGCM

    # Our plaintext to encrypt

    plain_text = b"Secret text to encrypt"

    # We do not require authenticated but unencrypted data, so set to None

    aad = None

    # Generate a secure key

    key = AESGCM.generate_key(bit_length=128)

    # Create a new AESGCM instance with our secure key

    aesgcm = AESGCM(key)

    # Note: nonce values _must_ be regenerated every time they are used.

    nonce = os.urandom(12)

    # Encrypt our plaintext

    cipher_text = aesgcm.encrypt(nonce, plain_text, aad)

    # Decrypt the plain text using the nonce and cipher_text

    aesgcm.decrypt(nonce, cipher_text, aad)

    ```


    For more information on the cryptography module see:

    - https://cryptography.io/en/latest/

    '
  metadata:
    category: security
    cwe: CWE-327
    owasp:
    - A3:2017-Sensitive Data Exposure
    - A02:2021-Cryptographic Failures
    security-severity: Medium
    shortDescription: Use of a broken or risky cryptographic algorithm
  patterns:
  - pattern-either:
    - pattern: Cryptodome.Cipher.XOR.new(...)
    - pattern: Crypto.Cipher.XOR.new(...)
  severity: WARNING
- id: python_crypto_rule-crypto-hash-md5
  languages:
  - python
  message: 'The application was found using an insecure or risky digest or signature
    algorithm. MD5

    and SHA1 hash algorithms have been found to be vulnerable to producing collisions.


    This means

    that two different values, when hashed, can lead to the same hash value. If the
    application is

    trying

    to use these hash methods for storing passwords, then it is recommended to switch
    to a

    password hashing

    algorithm such as Argon2id or PBKDF2.

    It is strongly recommended that a standard digest algorithm be chosen instead
    as implementing

    a custom algorithm is prone to errors.


    Note that the `Crypto` and `Cryptodome` Python packages are no longer recommended
    for

    new applications, instead consider using the [cryptography](https://cryptography.io/)
    package.


    Example of creating a SHA-384 hash using the `cryptography` package:

    ```

    from cryptography.hazmat.primitives import hashes

    # Create a SHA384 digest

    digest = hashes.Hash(hashes.SHA384())

    # Update the digest with some initial data

    digest.update(b"some data to hash")

    # Add more data to the digest

    digest.update(b"some more data")

    # Finalize the digest as bytes

    result = digest.finalize()

    ```


    For more information on secure password storage see OWASP:

    - https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html


    For more information on the cryptography module see:

    - https://cryptography.io/en/latest/

    '
  metadata:
    category: security
    cwe: CWE-327
    owasp:
    - A3:2017-Sensitive Data Exposure
    - A02:2021-Cryptographic Failures
    security-severity: Medium
    shortDescription: Use of a broken or risky cryptographic algorithm
  patterns:
  - pattern-either:
    - pattern: Crypto.Hash.MD5.new(...)
    - pattern: Cryptodome.Hash.MD5.new (...)
  severity: WARNING
- id: python_crypto_rule-crypto-hash-sha1
  languages:
  - python
  message: 'The application was found using an insecure or risky digest or signature
    algorithm. MD5

    and SHA1 hash algorithms have been found to be vulnerable to producing collisions.


    This means

    that two different values, when hashed, can lead to the same hash value. If the
    application is

    trying

    to use these hash methods for storing passwords, then it is recommended to switch
    to a

    password hashing

    algorithm such as Argon2id or PBKDF2.

    It is strongly recommended that a standard digest algorithm be chosen instead
    as implementing

    a custom algorithm is prone to errors.


    Note that the `Crypto` and `Cryptodome` Python packages are no longer recommended
    for

    new applications, instead consider using the [cryptography](https://cryptography.io/)
    package.


    Example of creating a SHA-384 hash using the `cryptography` package:

    ```

    from cryptography.hazmat.primitives import hashes

    # Create a SHA384 digest

    digest = hashes.Hash(hashes.SHA384())

    # Update the digest with some initial data

    digest.update(b"some data to hash")

    # Add more data to the digest

    digest.update(b"some more data")

    # Finalize the digest as bytes

    result = digest.finalize()

    ```


    For more information on secure password storage see OWASP:

    - https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html


    For more information on the cryptography module see:

    - https://cryptography.io/en/latest/

    '
  metadata:
    category: security
    cwe: CWE-327
    owasp:
    - A3:2017-Sensitive Data Exposure
    - A02:2021-Cryptographic Failures
    security-severity: Medium
    shortDescription: Use of a broken or risky cryptographic algorithm
  patterns:
  - pattern-either:
    - pattern: Crypto.Hash.SHA.new(...)
    - pattern: Cryptodome.Hash.SHA.new (...)
  severity: WARNING
- id: python_crypto_rule-hashlib-new-insecure-functions
  languages:
  - python
  message: 'The application was found using an insecure or risky digest or signature
    algorithm. MD2, MD4,

    MD5  and SHA1 hash algorithms have been found to be vulnerable to producing collisions.


    This means

    that two different values, when hashed, can lead to the same hash value. If the
    application is

    trying

    to use these hash methods for storing passwords, then it is recommended to switch
    to a

    password hashing

    algorithm such as Argon2id or PBKDF2.

    It is strongly recommended that a standard digest algorithm be chosen instead
    as implementing

    a custom algorithm is prone to errors.


    Example using `hashlib.sha384()` to create a SHA384 hash:

    ```

    import hashlib

    # Create a SHA384 digest

    digest = hashlib.sha384()

    # Update the digest with some initial data

    digest.update(b"some data to hash")

    # Add more data to the digest

    digest.update(b"some more data")

    # Finalize the digest as bytes

    digest.digest()

    ```

    '
  metadata:
    category: security
    cwe: CWE-327
    owasp:
    - A3:2017-Sensitive Data Exposure
    - A02:2021-Cryptographic Failures
    security-severity: Medium
    shortDescription: Use of a broken or risky cryptographic algorithm
  patterns:
  - pattern-either:
    - pattern: hashlib.new("=~/[M|m][D|d][4|5]/", ...)
    - pattern: hashlib.new(..., name="=~/[M|m][D|d][4|5]/", ...)
    - pattern: hashlib.new('sha1')
    - pattern: hashlib.new(..., name='SHA1')
    - pattern: hashlib.new('sha', string='test')
    - pattern: hashlib.new(name='SHA', string='test')
  severity: WARNING
- id: python_crypto_rule-import-pycrypto
  languages:
  - python
  message: 'The application was detected importing `pycrypto`. This package has been
    deprecated as it

    contains

    security vulnerabilities.


    To remediate this issue, consider using the [cryptography](https://cryptography.io/)

    package instead.

    '
  metadata:
    category: security
    cwe: CWE-1104
    owasp:
    - A9:2017-Using Components with Known Vulnerabilities
    - A02:2021-Cryptographic Failures
    security-severity: Medium
    shortDescription: Use of unmaintained third party components
  pattern-either:
  - pattern: import pycryto
  - pattern: import Crypto.Cipher
  - pattern: import Crypto.Hash
  - pattern: import Crypto.IO
  - pattern: import Crypto.Protocol
  - pattern: import Crypto.PublicKey
  - pattern: import Crypto.Random
  - pattern: import Crypto.Signature
  - pattern: import Crypto.Util
  severity: ERROR
- id: python_crypto_rule-crypto-hazmat-cipher-blowfish
  languages:
  - python
  message: "The Blowfish encryption algorithm was meant as a drop-in replacement for\
    \ DES and was created in\n1993. Smaller key sizes may make the ciphertext vulnerable\
    \ to [birthday\nattacks](https://en.wikipedia.org/wiki/Birthday_attack). While\
    \ no known attacks against\nBlowfish\nexist, it should never be used to encrypt\
    \ files over 4GB in size. If possible consider\nusing ChaCha20Poly1305 or AES-GCM\
    \ instead of Blowfish.\n\nFor older applications that don't have support for `ChaCha20Poly1305`,\
    \ `AES-256-GCM` is\nrecommended, however it has many drawbacks:\n  - Slower than\
    \ `ChaCha20Poly1305`.\n  - Catastrophic failure if nonce values are reused.\n\n\
    Example using `ChaCha20Poly1305`:\n```\nimport os\n# Import ChaCha20Poly1305 from\
    \ cryptography\nfrom cryptography.hazmat.primitives.ciphers.aead import ChaCha20Poly1305\n\
    # Our plaintext to encrypt\nplain_text = b\"Secret text to encrypt\"\n# We do\
    \ not require authenticated but unencrypted data, so set to None\naad = None\n\
    # Generate a secure key\nkey = ChaCha20Poly1305.generate_key()\n# Create a new\
    \ ChaCha20Poly1305 instance with our secure key\nchacha = ChaCha20Poly1305(key)\n\
    # Note: nonce values _must_ be regenerated every time they are used.\nnonce =\
    \ os.urandom(12)\n# Encrypt our plaintext\ncipher_text = chacha.encrypt(nonce,\
    \ plain_text, aad)\n# Decrypt the plain text using the nonce and cipher_text\n\
    chacha.decrypt(nonce, cipher_text, aad)\n```\n\nExample using `AESGCM`:\n```\n\
    import os\n# Import AESGCM from cryptography\nfrom cryptography.hazmat.primitives.ciphers.aead\
    \ import AESGCM\n# Our plaintext to encrypt\nplain_text = b\"Secret text to encrypt\"\
    \n# We do not require authenticated but unencrypted data, so set to None\naad\
    \ = None\n# Generate a secure key\nkey = AESGCM.generate_key(bit_length=128)\n\
    # Create a new AESGCM instance with our secure key\naesgcm = AESGCM(key)\n# Note:\
    \ nonce values _must_ be regenerated every time they are used.\nnonce = os.urandom(12)\n\
    # Encrypt our plaintext\ncipher_text = aesgcm.encrypt(nonce, plain_text, aad)\n\
    # Decrypt the plain text using the nonce and cipher_text\naesgcm.decrypt(nonce,\
    \ cipher_text, aad)\n```\n\nFor more information on the cryptography module see:\n\
    - https://cryptography.io/en/latest/\n"
  metadata:
    category: security
    cwe: CWE-327
    owasp:
    - A3:2017-Sensitive Data Exposure
    - A02:2021-Cryptographic Failures
    security-severity: Medium
    shortDescription: Use of a broken or risky cryptographic algorithm
  pattern: cryptography.hazmat.primitives.ciphers.algorithms.Blowfish(...)
  severity: WARNING
- id: python_crypto_rule-crypto-hazmat-cipher-arc4
  languages:
  - python
  message: 'DES, TripleDES, RC2 and RC4 are all considered broken or insecure cryptographic
    algorithms.

    Newer algorithms apply message integrity to validate ciphertext has not been tampered

    with. Consider using `ChaCha20Poly1305` instead as it is easier and faster than
    the

    alternatives such as `AES-256-GCM`.


    For older applications that don''t have support for `ChaCha20Poly1305`,

    `AES-256-GCM` is recommended, however it has many drawbacks:

    - Slower than `ChaCha20Poly1305`.

    - Catastrophic failure if nonce values are reused.


    Example using `ChaCha20Poly1305`:

    ```

    import os

    # Import ChaCha20Poly1305 from cryptography

    from cryptography.hazmat.primitives.ciphers.aead import ChaCha20Poly1305

    # Our plaintext to encrypt

    plain_text = b"Secret text to encrypt"

    # We do not require authenticated but unencrypted data, so set to None

    aad = None

    # Generate a secure key

    key = ChaCha20Poly1305.generate_key()

    # Create a new ChaCha20Poly1305 instance with our secure key

    chacha = ChaCha20Poly1305(key)

    # Note: nonce values _must_ be regenerated every time they are used.

    nonce = os.urandom(12)

    # Encrypt our plaintext

    cipher_text = chacha.encrypt(nonce, plain_text, aad)

    # Decrypt the plain text using the nonce and cipher_text

    chacha.decrypt(nonce, cipher_text, aad)

    ```


    Example using `AESGCM`:

    ```

    import os

    # Import AESGCM from cryptography

    from cryptography.hazmat.primitives.ciphers.aead import AESGCM

    # Our plaintext to encrypt

    plain_text = b"Secret text to encrypt"

    # We do not require authenticated but unencrypted data, so set to None

    aad = None

    # Generate a secure key

    key = AESGCM.generate_key(bit_length=128)

    # Create a new AESGCM instance with our secure key

    aesgcm = AESGCM(key)

    # Note: nonce values _must_ be regenerated every time they are used.

    nonce = os.urandom(12)

    # Encrypt our plaintext

    cipher_text = aesgcm.encrypt(nonce, plain_text, aad)

    # Decrypt the plain text using the nonce and cipher_text

    aesgcm.decrypt(nonce, cipher_text, aad)

    ```


    For more information on the cryptography module see:

    - https://cryptography.io/en/latest/

    '
  metadata:
    category: security
    cwe: CWE-327
    owasp:
    - A3:2017-Sensitive Data Exposure
    - A02:2021-Cryptographic Failures
    security-severity: Medium
    shortDescription: Use of a broken or risky cryptographic algorithm
  pattern: cryptography.hazmat.primitives.ciphers.algorithms.ARC4(...)
  severity: WARNING
- id: python_crypto_rule-cipher-modes
  languages:
  - python
  message: "Cryptographic algorithms provide many different modes of operation, only\
    \ some of which provide\nmessage integrity. Without message integrity it could\
    \ be possible for an adversary to attempt\nto tamper with the ciphertext which\
    \ could lead to compromising the encryption key. Newer\nalgorithms\napply message\
    \ integrity to validate ciphertext has not been tampered with.\n\nInstead of using\
    \ an algorithm that requires configuring a cipher mode, an algorithm\nthat has\
    \ built-in message integrity should be used. Consider using `ChaCha20Poly1305`\
    \ or\n`AES-256-GCM` instead.\n\nFor older applications that don't have support\
    \ for `ChaCha20Poly1305`, `AES-256-GCM` is\nrecommended, however it has many drawbacks:\n\
    \  - Slower than `ChaCha20Poly1305`.\n  - Catastrophic failure if nonce values\
    \ are reused.\n\nExample using `ChaCha20Poly1305`:\n```\nimport os\n# Import ChaCha20Poly1305\
    \ from cryptography\nfrom cryptography.hazmat.primitives.ciphers.aead import ChaCha20Poly1305\n\
    # Our plaintext to encrypt\nplain_text = b\"Secret text to encrypt\"\n# We do\
    \ not require authenticated but unencrypted data, so set to None\naad = None\n\
    # Generate a secure key\nkey = ChaCha20Poly1305.generate_key()\n# Create a new\
    \ ChaCha20Poly1305 instance with our secure key\nchacha = ChaCha20Poly1305(key)\n\
    # Note: nonce values _must_ be regenerated every time they are used.\nnonce =\
    \ os.urandom(12)\n# Encrypt our plaintext\ncipher_text = chacha.encrypt(nonce,\
    \ plain_text, aad)\n# Decrypt the plain text using the nonce and cipher_text\n\
    chacha.decrypt(nonce, cipher_text, aad)\n```\n\nExample using `AESGCM`:\n```\n\
    import os\n# Import AESGCM from cryptography\nfrom cryptography.hazmat.primitives.ciphers.aead\
    \ import AESGCM\n# Our plaintext to encrypt\nplain_text = b\"Secret text to encrypt\"\
    \n# We do not require authenticated but unencrypted data, so set to None\naad\
    \ = None\n# Generate a secure key\nkey = AESGCM.generate_key(bit_length=128)\n\
    # Create a new AESGCM instance with our secure key\naesgcm = AESGCM(key)\n# Note:\
    \ nonce values _must_ be regenerated every time they are used.\nnonce = os.urandom(12)\n\
    # Encrypt our plaintext\ncipher_text = aesgcm.encrypt(nonce, plain_text, aad)\n\
    # Decrypt the plain text using the nonce and cipher_text\naesgcm.decrypt(nonce,\
    \ cipher_text, aad)\n```\n\nFor more information on the cryptography module see:\n\
    - https://cryptography.io/en/latest/\n"
  metadata:
    category: security
    cwe: CWE-327
    owasp:
    - A3:2017-Sensitive Data Exposure
    - A02:2021-Cryptographic Failures
    security-severity: Medium
    shortDescription: Use of a broken or risky cryptographic algorithm
  pattern: cryptography.hazmat.primitives.ciphers.modes.ECB(...)
  severity: WARNING
- id: python_crypto_rule-hash-md2
  languages:
  - python
  message: 'The application was found using an insecure or risky digest or signature
    algorithm. MD2, MD5

    and SHA1 hash algorithms have been found to be vulnerable to producing collisions.


    This means

    that two different values, when hashed, can lead to the same hash value. If the
    application is

    trying

    to use these hash methods for storing passwords, then it is recommended to switch
    to a

    password hashing

    algorithm such as Argon2id or PBKDF2.


    Note that the `Crypto` and `Cryptodome` Python packages are no longer recommended
    for

    new applications, instead consider using the [cryptography](https://cryptography.io/)
    package.


    Example of creating a SHA-384 hash using the `cryptography` package:

    ```

    from cryptography.hazmat.primitives import hashes

    # Create a SHA384 digest

    digest = hashes.Hash(hashes.SHA384())

    # Update the digest with some initial data

    digest.update(b"some data to hash")

    # Add more data to the digest

    digest.update(b"some more data")

    # Finalize the digest as bytes

    result = digest.finalize()

    ```


    For more information on secure password storage see OWASP:

    - https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html


    For more information on the cryptography module see:

    - https://cryptography.io/en/latest/

    '
  metadata:
    category: security
    cwe: CWE-327
    owasp:
    - A3:2017-Sensitive Data Exposure
    - A02:2021-Cryptographic Failures
    security-severity: Medium
    shortDescription: Use of a broken or risky cryptographic algorithm
  patterns:
  - pattern-either:
    - pattern: Crypto.Hash.MD2.new(...)
    - pattern: Cryptodome.Hash.MD2.new (...)
  severity: WARNING
- id: python_crypto_rule-crypto-cipher-rc4
  languages:
  - python
  message: 'DES, TripleDES, RC2 and RC4 are all considered broken or insecure cryptographic
    algorithms.

    Newer algorithms apply message integrity to validate ciphertext has not been tampered

    with. Consider using `ChaCha20Poly1305` instead as it is easier and faster than
    the

    alternatives such as `AES-256-GCM`.


    For older applications that don''t have support for `ChaCha20Poly1305`,

    `AES-256-GCM` is recommended, however it has many drawbacks:

    - Slower than `ChaCha20Poly1305`.

    - Catastrophic failure if nonce values are reused.


    Note that the `Crypto` and `Cryptodome` Python packages are no longer recommended
    for

    new applications, instead consider using the [cryptography](https://cryptography.io/)
    package.


    Example using `ChaCha20Poly1305`:

    ```

    import os

    # Import ChaCha20Poly1305 from cryptography

    from cryptography.hazmat.primitives.ciphers.aead import ChaCha20Poly1305

    # Our plaintext to encrypt

    plain_text = b"Secret text to encrypt"

    # We do not require authenticated but unencrypted data, so set to None

    aad = None

    # Generate a secure key

    key = ChaCha20Poly1305.generate_key()

    # Create a new ChaCha20Poly1305 instance with our secure key

    chacha = ChaCha20Poly1305(key)

    # Note: nonce values _must_ be regenerated every time they are used.

    nonce = os.urandom(12)

    # Encrypt our plaintext

    cipher_text = chacha.encrypt(nonce, plain_text, aad)

    # Decrypt the plain text using the nonce and cipher_text

    chacha.decrypt(nonce, cipher_text, aad)

    ```


    Example using `AESGCM`:

    ```

    import os

    # Import AESGCM from cryptography

    from cryptography.hazmat.primitives.ciphers.aead import AESGCM

    # Our plaintext to encrypt

    plain_text = b"Secret text to encrypt"

    # We do not require authenticated but unencrypted data, so set to None

    aad = None

    # Generate a secure key

    key = AESGCM.generate_key(bit_length=128)

    # Create a new AESGCM instance with our secure key

    aesgcm = AESGCM(key)

    # Note: nonce values _must_ be regenerated every time they are used.

    nonce = os.urandom(12)

    # Encrypt our plaintext

    cipher_text = aesgcm.encrypt(nonce, plain_text, aad)

    # Decrypt the plain text using the nonce and cipher_text

    aesgcm.decrypt(nonce, cipher_text, aad)

    ```


    For more information on the cryptography module see:

    - https://cryptography.io/en/latest/

    '
  metadata:
    category: security
    cwe: CWE-327
    owasp:
    - A3:2017-Sensitive Data Exposure
    - A02:2021-Cryptographic Failures
    security-severity: Medium
    shortDescription: Use of a broken or risky cryptographic algorithm
  patterns:
  - pattern-either:
    - pattern: Cryptodome.Cipher.ARC4.new(...)
    - pattern: Crypto.Cipher.ARC4.new(...)
  severity: WARNING
- id: python_crypto_rule-crypto-encrypt-ec
  languages:
  - python
  message: "The application was found using an insufficient curve size for the Elliptical\n\
    Cryptography (EC) asymmetric algorithm. NIST recommends using a key size of\n\
    224 or greater.\n\nTo remediate this issue, replace the current key size with\
    \ `ec.SECP384R1`,\n\nExample using `ec.SECP384R1`:\n```\nfrom cryptography.hazmat.primitives.asymmetric\
    \ import ec\n# Generate an EC private key using SECP384R1\nprivate_key = ec.generate_private_key(\n\
    \    ec.SECP384R1()\n)\n# Work with/sign data using the key\n# ...\n```\n\nFor\
    \ more information on the cryptography module's EC section see:\n- https://cryptography.io/en/latest/hazmat/primitives/asymmetric/ec/\n"
  metadata:
    category: security
    cwe: CWE-326
    owasp:
    - A3:2017-Sensitive Data Exposure
    - A02:2021-Cryptographic Failures
    security-severity: Medium
    shortDescription: Inadequate encryption strength
  patterns:
  - pattern-inside: cryptography.hazmat.primitives.asymmetric.ec.generate_private_key(...)
  - pattern: cryptography.hazmat.primitives.asymmetric.ec.$SIZE
  - metavariable-pattern:
      metavariable: $SIZE
      pattern-either:
      - pattern: SECP192R1
      - pattern: SECT163K1
      - pattern: SECT163R2
  - focus-metavariable: $SIZE
  severity: ERROR
- id: python_crypto_rule-hash-md5
  languages:
  - python
  message: "The application was found using an insecure or risky digest or signature\
    \ algorithm. MD2, MD4,\n MD5  and SHA1 hash algorithms have been found to be vulnerable\
    \ to producing collisions.\n\nThis means\nthat two different values, when hashed,\
    \ can lead to the same hash value. If the application is\ntrying\nto use these\
    \ hash methods for storing passwords, then it is recommended to switch to a\n\
    password hashing\nalgorithm such as Argon2id or PBKDF2.\n\nNote that the `Crypto`\
    \ and `Cryptodome` Python packages are no longer recommended for\nnew applications,\
    \ instead consider using the [cryptography](https://cryptography.io/) package.\n\
    \nExample of creating a SHA-384 hash using the `cryptography` package:\n```\n\
    from cryptography.hazmat.primitives import hashes\n# Create a SHA384 digest\n\
    digest = hashes.Hash(hashes.SHA384())\n# Update the digest with some initial data\n\
    digest.update(b\"some data to hash\")\n# Add more data to the digest\ndigest.update(b\"\
    some more data\")\n# Finalize the digest as bytes\nresult = digest.finalize()\n\
    ```\n\nFor more information on secure password storage see OWASP:\n- https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html\n\
    \nFor more information on the cryptography module see:\n- https://cryptography.io/en/latest/\n"
  metadata:
    category: security
    cwe: CWE-327
    owasp:
    - A3:2017-Sensitive Data Exposure
    - A02:2021-Cryptographic Failures
    security-severity: Medium
    shortDescription: Use of a broken or risky cryptographic algorithm
  pattern: hashlib.md5(...)
  severity: WARNING
- id: python_crypto_rule-crypto.hazmat-hash-md5
  languages:
  - python
  message: 'The application was found using an insecure or risky digest or signature
    algorithm. MD2, MD5

    and SHA1 hash algorithms have been found to be vulnerable to producing collisions.


    This means

    that two different values, when hashed, can lead to the same hash value. If the
    application is

    trying

    to use these hash methods for storing passwords, then it is recommended to switch
    to a

    password hashing

    algorithm such as Argon2id or PBKDF2.

    It is strongly recommended that a standard digest algorithm be chosen instead
    as implementing

    a custom algorithm is prone to errors.


    Example of creating a SHA-384 hash using the `cryptography` package:

    ```

    from cryptography.hazmat.primitives import hashes

    # Create a SHA384 digest

    digest = hashes.Hash(hashes.SHA384())

    # Update the digest with some initial data

    digest.update(b"some data to hash")

    # Add more data to the digest

    digest.update(b"some more data")

    # Finalize the digest as bytes

    result = digest.finalize()

    ```


    For more information on secure password storage see OWASP:

    - https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html


    For more information on the cryptography module see:

    - https://cryptography.io/en/latest/

    '
  metadata:
    category: security
    cwe: CWE-327
    owasp:
    - A3:2017-Sensitive Data Exposure
    - A02:2021-Cryptographic Failures
    security-severity: Medium
    shortDescription: Use of a broken or risky cryptographic algorithm
  pattern: cryptography.hazmat.primitives.hashes.MD5(...)
  severity: WARNING
- id: python_crypto_rule-hash-md4
  languages:
  - python
  message: "The application was found using an insecure or risky digest or signature\
    \ algorithm. MD2, MD4,\n MD5  and SHA1 hash algorithms have been found to be vulnerable\
    \ to producing collisions.\n\nThis means\nthat two different values, when hashed,\
    \ can lead to the same hash value. If the application is\ntrying\nto use these\
    \ hash methods for storing passwords, then it is recommended to switch to a\n\
    password hashing\nalgorithm such as Argon2id or PBKDF2.\n\nNote that the `Crypto`\
    \ and `Cryptodome` Python packages are no longer recommended for\nnew applications,\
    \ instead consider using the [cryptography](https://cryptography.io/) package.\n\
    \nExample of creating a SHA-384 hash using the `cryptography` package:\n```\n\
    from cryptography.hazmat.primitives import hashes\n# Create a SHA384 digest\n\
    digest = hashes.Hash(hashes.SHA384())\n# Update the digest with some initial data\n\
    digest.update(b\"some data to hash\")\n# Add more data to the digest\ndigest.update(b\"\
    some more data\")\n# Finalize the digest as bytes\nresult = digest.finalize()\n\
    ```\n\nFor more information on secure password storage see OWASP:\n- https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html\n\
    \nFor more information on the cryptography module see:\n- https://cryptography.io/en/latest/\n"
  metadata:
    category: security
    cwe: CWE-327
    owasp:
    - A3:2017-Sensitive Data Exposure
    - A02:2021-Cryptographic Failures
    security-severity: Medium
    shortDescription: Use of a broken or risky cryptographic algorithm
  patterns:
  - pattern-either:
    - pattern: Crypto.Hash.MD4.new(...)
    - pattern: Cryptodome.Hash.MD4.new (...)
  severity: WARNING
- id: python_crypto_rule-crypto-cipher-rc2
  languages:
  - python
  message: 'DES, TripleDES, RC2 and RC4 are all considered broken or insecure cryptographic
    algorithms.

    Newer algorithms apply message integrity to validate ciphertext has not been tampered

    with. Consider using `ChaCha20Poly1305` instead as it is easier and faster than
    the

    alternatives such as `AES-256-GCM`.


    For older applications that don''t have support for `ChaCha20Poly1305`,

    `AES-256-GCM` is recommended, however it has many drawbacks:

    - Slower than `ChaCha20Poly1305`.

    - Catastrophic failure if nonce values are reused.


    Note that the `Crypto` and `Cryptodome` Python packages are no longer recommended
    for

    new applications, instead consider using the [cryptography](https://cryptography.io/)
    package.


    Example using `ChaCha20Poly1305`:

    ```

    import os

    # Import ChaCha20Poly1305 from cryptography

    from cryptography.hazmat.primitives.ciphers.aead import ChaCha20Poly1305

    # Our plaintext to encrypt

    plain_text = b"Secret text to encrypt"

    # We do not require authenticated but unencrypted data, so set to None

    aad = None

    # Generate a secure key

    key = ChaCha20Poly1305.generate_key()

    # Create a new ChaCha20Poly1305 instance with our secure key

    chacha = ChaCha20Poly1305(key)

    # Note: nonce values _must_ be regenerated every time they are used.

    nonce = os.urandom(12)

    # Encrypt our plaintext

    cipher_text = chacha.encrypt(nonce, plain_text, aad)

    # Decrypt the plain text using the nonce and cipher_text

    chacha.decrypt(nonce, cipher_text, aad)

    ```


    Example using `AESGCM`:

    ```

    import os

    # Import AESGCM from cryptography

    from cryptography.hazmat.primitives.ciphers.aead import AESGCM

    # Our plaintext to encrypt

    plain_text = b"Secret text to encrypt"

    # We do not require authenticated but unencrypted data, so set to None

    aad = None

    # Generate a secure key

    key = AESGCM.generate_key(bit_length=128)

    # Create a new AESGCM instance with our secure key

    aesgcm = AESGCM(key)

    # Note: nonce values _must_ be regenerated every time they are used.

    nonce = os.urandom(12)

    # Encrypt our plaintext

    cipher_text = aesgcm.encrypt(nonce, plain_text, aad)

    # Decrypt the plain text using the nonce and cipher_text

    aesgcm.decrypt(nonce, cipher_text, aad)

    ```


    For more information on the cryptography module see:

    - https://cryptography.io/en/latest/

    '
  metadata:
    category: security
    cwe: CWE-327
    owasp:
    - A3:2017-Sensitive Data Exposure
    - A02:2021-Cryptographic Failures
    security-severity: Medium
    shortDescription: Use of a broken or risky cryptographic algorithm
  patterns:
  - pattern-either:
    - pattern: Cryptodome.Cipher.ARC2.new(...)
    - pattern: Crypto.Cipher.ARC2.new
  severity: WARNING
- id: python_ssl_rule-unverified-context
  languages:
  - python
  message: "The application was found creating a SSL context using the `_create_unverified_context`.\n\
    This effectively disables the validation of server certificates.\n\nThis allows\
    \ for an adversary who is in between the application and the target host to intercept\n\
    potentially sensitive information or transmit malicious data.\n\nTo remediate\
    \ this issue remove the call to `_create_unverified_context` and either create\
    \ a\ndefault\ncontext using `ssl.create_default_context` or create a context with\
    \ TLS 1.3.\n\nExample creating a TLS 1.3 client socket connection by using a newer\
    \ version of Python\n(3.11.4) and\nthe SSL module:\n```\nimport ssl\nimport socket\n\
    \n# Create our initial socket\nwith socket.socket(socket.AF_INET, socket.SOCK_STREAM)\
    \ as sock:\n    # Connect the socket\n    sock.connect(('www.example.org', 443))\n\
    \n    # Create a new SSLContext with protocol set to ssl.PROTOCOL_TLS_CLIENT\n\
    \    # This will auto-select the highest grade TLS protocol version (1.3)\n  \
    \  context = ssl.SSLContext(protocol=ssl.PROTOCOL_TLS_CLIENT)\n    # Load our\
    \ a certificates for server certificate authentication\n    context.load_verify_locations('cert.pem')\n\
    \    # Create our TLS socket, and validate the server hostname matches\n    with\
    \ context.wrap_socket(sock, server_hostname=\"www.example.org\") as tls_sock:\n\
    \        # Send some bytes over the socket (HTTP request in this case)\\\n   \
    \     data = bytes('GET / HTTP/1.1\\r\\nHost: example.org\\r\\n\\r\\n', 'utf-8')\n\
    \        sent_bytes = tls_sock.send(data)\n        # Validate number of sent bytes\n\
    \        # ...\n        # Read the response\n        resp = tls_sock.recv()\n\
    \        # Work with the response\n        # ...\n```\n\nUnverified SSL context\
    \ detected. This will permit insecure connections without `verifyingSSL`\ncertificates.\
    \ Use `ssl.create_default_context()` instead.\n"
  metadata:
    category: security
    cwe: CWE-295
    owasp:
    - A2:2017-Broken Authentication
    - A07:2021-Identification and Authentication Failures
    security-severity: Medium
    shortDescription: Improper certificate validation
  pattern: ssl._create_unverified_context(...)
  severity: ERROR
- id: python_ssl_rule-ssl-no-version
  languages:
  - python
  message: "The application was found calling `ssl.wrap_socket` without a TLS protocol\
    \ version specified.\nAdditionally, `ssl.wrap_socket` has been deprecated since\
    \ Python 3.7. It is strongly\nrecommended\nthat newer applications use TLS 1.2\
    \ or 1.3 and `SSLContext.wrap_socket`.\n\nTo remediate this issue, create a new\
    \ TLS context and pass in `ssl.PROTOCOL_TLS_CLIENT`\nfor clients or `ssl.PROTOCOL_TLS_SERVER`\
    \ for servers to the `ssl.SSLContext(...)` `protocol=`\nargument. When converting\
    \ the socket to a TLS socket, use the new `SSLContext.wrap_socket`\nmethod instead.\n\
    \n\nExample creating a TLS 1.3 client socket connection by using a newer version\
    \ of Python\n(3.11.4) and\nthe SSL module:\n```\nimport ssl\nimport socket\n\n\
    # Create our initial socket\nwith socket.socket(socket.AF_INET, socket.SOCK_STREAM)\
    \ as sock:\n    # Connect the socket\n    sock.connect(('www.example.org', 443))\n\
    \n    # Create a new SSLContext with protocol set to ssl.PROTOCOL_TLS_CLIENT\n\
    \    # This will auto-select the highest grade TLS protocol version (1.3)\n  \
    \  context = ssl.SSLContext(protocol=ssl.PROTOCOL_TLS_CLIENT)\n    # Load our\
    \ a certificates for server certificate authentication\n    context.load_verify_locations('cert.pem')\n\
    \    # Create our TLS socket, and validate the server hostname matches\n    with\
    \ context.wrap_socket(sock, server_hostname=\"www.example.org\") as tls_sock:\n\
    \        # Send some bytes over the socket (HTTP request in this case)\\\n   \
    \     data = bytes('GET / HTTP/1.1\\r\\nHost: example.org\\r\\n\\r\\n', 'utf-8')\n\
    \        sent_bytes = tls_sock.send(data)\n        # Validate number of sent bytes\n\
    \        # ...\n        # Read the response\n        resp = tls_sock.recv()\n\
    \        # Work with the response\n        # ...\n```\n\nFor more information\
    \ on the ssl module see:\n- https://docs.python.org/3/library/ssl.html\n"
  metadata:
    category: security
    cwe: CWE-326
    owasp:
    - A3:2017-Sensitive Data Exposure
    - A02:2021-Cryptographic Failures
    security-severity: Medium
    shortDescription: Inadequate encryption strength
  patterns:
  - pattern: ssl.wrap_socket()
  severity: WARNING
- id: python_ssl_rule-ssl-with-bad-version
  languages:
  - python
  message: "The application was found calling an SSL module with SSL or TLS protocols\
    \ that have known\ndeficiencies.\nIt is strongly recommended that newer applications\
    \ use TLS 1.2 or 1.3 and\n`SSLContext.wrap_socket`.\n\nIf using the `pyOpenSSL`\
    \ module, please note that it has been deprecated and the Python\nCryptographic\
    \ Authority\nstrongly suggests moving to use the [pyca/cryptography](https://github.com/pyca/cryptography)\n\
    module instead.\n\nTo remediate this issue for the `ssl` module, create a new\
    \ TLS context and pass in\n`ssl.PROTOCOL_TLS_CLIENT` for clients or `ssl.PROTOCOL_TLS_SERVER`\
    \ for servers to the\n`ssl.SSLContext(...)` `protocol=`\nargument. When converting\
    \ the socket to a TLS socket, use the new `SSLContext.wrap_socket`\nmethod instead.\n\
    \nExample creating a TLS 1.3 client socket connection by using a newer version\
    \ of Python\n(3.11.4) and\nthe SSL module:\n```\nimport ssl\nimport socket\n\n\
    # Create our initial socket\nwith socket.socket(socket.AF_INET, socket.SOCK_STREAM)\
    \ as sock:\n    # Connect the socket\n    sock.connect(('www.example.org', 443))\n\
    \n    # Create a new SSLContext with protocol set to ssl.PROTOCOL_TLS_CLIENT\n\
    \    # This will auto-select the highest grade TLS protocol version (1.3)\n  \
    \  context = ssl.SSLContext(protocol=ssl.PROTOCOL_TLS_CLIENT)\n    # Load our\
    \ a certificates for server certificate authentication\n    context.load_verify_locations('cert.pem')\n\
    \    # Create our TLS socket, and validate the server hostname matches\n    with\
    \ context.wrap_socket(sock, server_hostname=\"www.example.org\") as tls_sock:\n\
    \        # Send some bytes over the socket (HTTP request in this case)\\\n   \
    \     data = bytes('GET / HTTP/1.1\\r\\nHost: example.org\\r\\n\\r\\n', 'utf-8')\n\
    \        sent_bytes = tls_sock.send(data)\n        # Validate number of sent bytes\n\
    \        # ...\n        # Read the response\n        resp = tls_sock.recv()\n\
    \        # Work with the response\n        # ...\n```\n\nFor more information\
    \ on the ssl module see:\n- https://docs.python.org/3/library/ssl.html\n\nFor\
    \ more information on pyca/cryptography and openssl see:\n- https://cryptography.io/en/latest/openssl/\n"
  metadata:
    category: security
    cwe: CWE-326
    owasp:
    - A3:2017-Sensitive Data Exposure
    - A02:2021-Cryptographic Failures
    security-severity: Medium
    shortDescription: Inadequate Encryption Strength
  patterns:
  - pattern-either:
    - pattern: ssl.PROTOCOL_SSLv2
    - pattern: ssl.PROTOCOL_SSLv3
    - pattern: ssl.PROTOCOL_TLSv1
    - pattern: ssl.PROTOCOL_TLSv1_1
    - pattern: pyOpenSSL.SSL.SSLv2_METHOD
    - pattern: pyOpenSSL.SSL.SSLv23_METHOD
    - pattern: pyOpenSSL.SSL.SSLv3_METHOD
    - pattern: pyOpenSSL.SSL.TLSv1_METHOD
    - pattern: pyOpenSSL.SSL.TLSv1_1_METHOD
  severity: ERROR
- id: python_ssl_rule-req-no-certvalid
  languages:
  - python
  message: 'The application was found using the `requests` module without configuring
    a timeout value for

    connections. The `verify=False` argument has been set, which effectively disables
    the

    validation

    of server certificates.


    This allows for an adversary who is in between the application and the target
    host to intercept

    potentially sensitive information or transmit malicious data.


    To remediate this issue either remove the `verify=False` argument, or set `verify=True`to
    each

    `requests` call.


    Example verifying server certificates for an HTTP GET request:

    ```

    # Issue a GET request to https://example.com with a timeout of 10 seconds and
    verify the

    # server certificate explicitly.

    response = requests.get(''https://example.com'', timeout=10, verify=True)

    # Work with the response object

    # ...

    ```


    For more information on using the requests module see:

    - https://requests.readthedocs.io/en/latest/api/

    '
  metadata:
    category: security
    cwe: CWE-295
    owasp:
    - A2:2017-Broken Authentication
    - A07:2021-Identification and Authentication Failures
    security-severity: Medium
    shortDescription: Improper certificate validation
  patterns:
  - pattern-either:
    - pattern: requests.put(..., verify=False, ...)
    - pattern: requests.patch(..., verify=False, ...)
    - pattern: requests.delete(..., verify=False, ...)
    - pattern: requests.head(..., verify=False, ...)
    - pattern: requests.options(..., verify=False, ...)
    - pattern: requests.request(..., verify=False, ...)
    - pattern: requests.get(..., verify=False, ...)
    - pattern: requests.post(..., verify=False, ...)
  severity: ERROR
- id: python_snmp_rule-snmp-weak-cryptography
  languages:
  - python
  message: "Pysnmp was detected using SNMPv3 without authentication or encryption\n\
    protections enabled.\n\n- Use of `usmNoAuthProtocol` or `usmNoPrivProtocol` indicates\
    \ that\neither authentication or privacy, respectively, is not being used.  \n\
    - The absence of  `authKey` (or `authKey=None`) implies no authentication, \n\
    which is equivalent to using `usmNoAuthProtocol`. \n- The absence of `privKey`\
    \ (or `privKey=None`) implies no privacy (encryption), \nwhich is equivalent to\
    \ using `usmNoPrivProtocol`.\n\nTo enhance the security of your SNMP communications,\
    \ it is recommended to use both\nauthentication and privacy features in SNMPv3:\n\
    \n- Use SHA for Authentication: SHA (Secure Hash Algorithm) is a more secure option\
    \ \nfor SNMP message authentication. To use SHA, set the `authProtocol` to \n\
    `usmHMACSHAAuthProtocol` and provide a strong `authKey`.\n- Use AES for Privacy:\
    \ AES (Advanced Encryption Standard) is recommended for \nencrypting SNMP messages.\
    \ Set the `privProtocol` to `usmAesCfb128Protocol`\nor a similar AES-based protocol\
    \ and specify a strong `privKey`.\n\nExample of secure `UsmUserData` configuration:\n\
    ``` \n  from pysnmp.hlapi import UsmUserData, usmHMACSHAAuthProtocol, usmAesCfb128Protocol\n\
    \      \n  user_data = UsmUserData('username','authKey', 'privKey',          \
    \ \n                        authProtocol=usmHMACSHAAuthProtocol,\n           \
    \             privProtocol=usmAesCfb128Protocol)\n```\n"
  metadata:
    category: security
    cwe: CWE-319
    owasp:
    - A3:2017-Sensitive Data Exposure
    - A02:2021-Cryptographic Failures
    security-severity: Medium
    shortDescription: Cleartext transmission of sensitive information
  pattern-either:
  - pattern-regex: UsmUserData(.*usmNoAuthProtocol.*)
  - pattern-regex: UsmUserData(.*usmNoPrivProtocol.*)
  - pattern: 'UsmUserData(..., authKey=None, ...)

      '
  - pattern: 'UsmUserData(..., privKey=None, ...)

      '
  - pattern: 'UsmUserData(..., authProtocol=(1,3,6,1,6,3,10,1,1,1), ...)

      '
  - pattern: 'UsmUserData(..., privProtocol=(1,3,6,1,6,3,10,1,2,1), ...)

      '
  - patterns:
    - pattern-not: 'UsmUserData($NAME,$AUTHKEY,"...", ...)

        '
    - pattern-not: 'UsmUserData(..., privKey=$PRIVKEY, ...)

        '
    - pattern-not: 'UsmUserData(..., privProtocol=$PRIVPROT, ...)

        '
    - pattern: 'UsmUserData(...)

        '
  severity: WARNING
- id: python_snmp_rule-insecure-snmp-version
  languages:
  - python
  message: "Pysnmp was detected using versions SNMPv1 or SNMPv2. SNPMv1 and SNMPv2\
    \ are insecure\nand should no longer be used as they do not offer encryption.\n\
    \nIf possible, query SNMP devices using SNMPv3 instead.\n\nExample querying a\
    \ device using SNMPv3 with SHA-AES:\n```\nfrom pysnmp.hlapi import *\n# Create\
    \ the snpm iterator\niterator = getCmd(\n    SnmpEngine(),\n    # Configure using\
    \ SHA AES\n    UsmUserData('usr-sha-aes', 'authkey1', 'privkey1',\n          \
    \      authProtocol=USM_AUTH_HMAC96_SHA,\n                privProtocol=USM_PRIV_CFB128_AES),\n\
    \    UdpTransportTarget(('demo.snmplabs.com', 161)),\n    ContextData(),\n   \
    \ ObjectType(ObjectIdentity('SNMPv2-MIB', 'sysDescr', 0))\n)\n```\n\nFor more\
    \ information on using SNMPv3 with `Pysnmp` see:\n- https://pysnmp.readthedocs.io/en/latest/examples/hlapi/v3arch/asyncore/sync/manager/cmdgen/snmp-versions.html#snmpv3-auth-sha-privacy-aes128\n"
  metadata:
    category: security
    cwe: CWE-319
    owasp:
    - A3:2017-Sensitive Data Exposure
    - A02:2021-Cryptographic Failures
    security-severity: Medium
    shortDescription: Cleartext transmission of sensitive information
  pattern-either:
  - pattern: pysnmp.hlapi.CommunityData(..., mpModel=0, ...)
  - pattern: pysnmp.hlapi.CommunityData(..., mpModel=1, ...)
  severity: WARNING
- id: python_escaping_rule-use-of-mako-templates
  languages:
  - python
  message: "The application was found using mako templates without `default_filters`\n\
    being passed to the `Template` or `TemplateLookup` constructors. If using \nin\
    \ the context of HTML, this could lead to Cross-Site Scripting (XSS) attacks \n\
    when rendering with user-supplied input.\n\nUnfortunately, Jinja2 does not support\
    \ context-aware escaping, meaning it\nis insufficient to protect against XSS for\
    \ the various web contexts. It is \nimportant to encode the data depending on\
    \ the specific context it is used in. \nThere are at least six context types:\n\
    \n- Inside HTML tags `<div>context 1</div>`\n- Inside attributes: `<div class=\"\
    context 2\"></div>`\n- Inside event attributes `<button onclick=\"context 3\"\
    >button</button>`\n- Inside script blocks: `<script>var x = \"context 4\"</script>`\n\
    - Unsafe element HTML assignment: `element.innerHTML = \"context 5\"`\n- Inside\
    \ URLs: \n`<iframe src=\"context 6\"></iframe><a href=\"context 6\">link</a>`\n\
    \nScript blocks alone have multiple ways they need to be encoded. Extra care\n\
    must be taken if user input is ever output inside of script tags.\n\nUser input\
    \ that is displayed within the application must be encoded,\nsanitized or validated\
    \ to ensure it cannot be treated as HTML or executed \nas Javascript code. Care\
    \ must also be taken to not mix server-side templating \nwith client-side templating,\
    \ as the server-side templating will not encode things \nlike {{ 7*7 }} which\
    \ may execute client-side templating features.\n\nIt is _NOT_ advised to encode\
    \ user input prior to inserting into a data\nstore. The data will need to be encoded\
    \ depending on context of where it is output. \nIt is much safer to force the\
    \ displaying system to handle the encoding and \nnot attempt to guess how it should\
    \ be encoded.\n\nTo handle different contexts, one approach would be to write\
    \ custom mako\nfilters. Below is an example that escapes or encodes links and\
    \ \npotentially malicious script, note this does not include other contexts \n\
    such as CSS or attributes:\n```\n# filters.py module:\n\ndef escape_link(value):\n\
    \    bad_link = \"#JinjatmplZ\"\n    # Block any values that start with // as\
    \ that could be used to inject\n    # links to third party pages see:\nhttps://en.wikipedia.org/wiki/Wikipedia:Protocol-relative_URL\n\
    \    if value.startswith('//'):\n        return bad_link\n\n    # Only allow relative\
    \ links\n    # if you want to allow links that start with http or ws replace with\
    \ below:\n    # if not value.startswith('/'): and not value.startswith('http')\
    \ and not\nvalue.startswith('ws')\n    if not value.startswith('/'):\n       \
    \ return bad_link\n\n    return value\n\n# Create a replacement table\njs_replacement\
    \ = str.maketrans({\n    '\\0': \"\\\\u0000\",\n    '\\t': \"\\\\t\",\n    '\\\
    n': \"\\\\n\",\n    '\\v': \"\\\\u000b\",\n    '\\f': \"\\\\f`\",\n    '\\r':\
    \ \"\\\\r\",\n    '\"':  \"\\\\u0022\",\n    '`':  \"\\\\u0060\",\n    '&':  \"\
    \\\\u0026\",\n    '\\'': \"\\\\u0027\",\n    '+':  \"\\\\u002b\",\n    '/':  \"\
    \\\\/\",\n    '<':  \"\\\\u003c\",\n    '>':  \"\\\\u003e\",\n    '\\\\': \"\\\
    \\\\\\\",\n    '(': \"\\\\u0028\",\n    ')': \"\\\\u0029\",\n})\n\ndef escape_js(value):\n\
    \    # Escape the input for use in <script> context, USE WITH CAUTION\n    # It\
    \ is strongly recommended to never pass user-supplied input to\n    # the JavaScript\
    \ context.\n\n    # Translate any potential characters using our translation table\n\
    \    return value.translate(js_replacement)\n\n#####################################################################\n\
    # main module:                                                      #\n#####################################################################\n\
    from mako.template import Template\n\n# Define our template, note the calls to\
    \ our custom filters depending\n# on context\ntemplate_text = \"\"\"\n\n<!DOCTYPE\
    \ html>\n<html lang=\"en\">\n<head>\n    <title>My Webpage</title>\n</head>\n\
    <body>\n    <h1>My Webpage</h1>\n    ${html_context}\n    <a href=\"${link_context\
    \ | escape_link}\">link</a>\n    <script>${script_context | escape_js}</script>\n\
    </body>\n</html>\n\"\"\"\n\n# Load our template with default filters and our imported\
    \ filters for\n# usage in template files\nt = Template(template_text,\n      \
    \      # By default enable the html filter with 'h'\n            default_filters=['h'],\n\
    \            # Import our custom filters\n            imports=[\"from filters\
    \ import escape_link, escape_js\"])\n\n# Render our template\nprint(t.render(html_context=\"\
    <img src=x onerror=alert(1)>\",\n    link_context=\"/# onclick=alert(1)<script>alert(1)</script>\"\
    ,\n    script_context=\"alert(1)<img src=x onerror=alert(1)>\",)\n)\n```\n"
  metadata:
    category: security
    cwe: CWE-79
    owasp:
    - A7:2017-Cross-Site Scripting (XSS)
    - A03:2021-Injection
    security-severity: Medium
    shortDescription: Improper neutralization of input during web page generation
      ('Cross-site Scripting')
  patterns:
  - pattern-either:
    - pattern: mako.template.Template(...)
    - pattern: mako.lookup.TemplateLookup(...)
  - pattern-not: mako.lookup.TemplateLookup(..., default_filters=["..."])
  - pattern-not: mako.template.Template(..., default_filters=["..."])
  severity: WARNING
- id: python_escaping_rule-jinja2-autoescape-false
  languages:
  - python
  message: "The application was found using Jinja2 `Environment` without autoescaping\
    \ enabled. If using in\nthe context of HTML this could lead to Cross-Site Scripting\
    \ (XSS) attacks when rendering with\nuser-supplied input.\n\nUnfortunately, Jinja2\
    \ does not support context-aware escaping, meaning it is insufficient to\nprotect\
    \ against\nXSS for the various web contexts. It is important to encode the data\
    \ depending on the specific\ncontext\nit\nis used in. There are at least six context\
    \ types:\n\n- Inside HTML tags `<div>context 1</div>`\n- Inside attributes: `<div\
    \ class=\"context 2\"></div>`\n- Inside event attributes `<button onclick=\"context\
    \ 3\">button</button>`\n- Inside script blocks: `<script>var x = \"context 4\"\
    </script>`\n- Unsafe element HTML assignment: `element.innerHTML = \"context 5\"\
    `\n- Inside URLs: `<iframe src=\"context 6\"></iframe><a href=\"context 6\">link</a>`\n\
    \nScript blocks alone have multiple ways they need to be encoded. Extra care must\
    \ be taken if\nuser input\nis ever output inside of script tags.\n\nUser input\
    \ that is displayed within the application must be encoded, sanitized or validated\n\
    to ensure it cannot be treated as HTML or executed as Javascript code. Care must\
    \ also be\ntaken\nto not mix server-side templating with client-side templating,\
    \ as the server-side templating\nwill\nnot encode things like {{ 7*7 }} which\
    \ may execute client-side templating features.\n\nIt is _NOT_ advised to encode\
    \ user input prior to inserting into a data store. The data will\nneed to be\n\
    encoded depending on context of where it is output. It is much safer to force\
    \ the displaying\nsystem to\nhandle the encoding and not attempt to guess how\
    \ it should be encoded.\n\nTo handle different contexts, one approach would be\
    \ to write custom Jinja2 filters. Below is\nan example\nthat escapes or encodes\
    \ links and potentially malicious script, note this does not include\nother contexts\n\
    such as CSS or attributes:\n```\nfrom jinja2 import Environment, select_autoescape,\
    \ FileSystemLoader\nfrom jinja2 import pass_eval_context\nfrom markupsafe import\
    \ Markup, escape\n\n@pass_eval_context\ndef escape_link(eval_ctx, value):\n  \
    \  bad_link = \"#JinjatmplZ\"\n    # Block any values that start with // as that\
    \ could be used to inject\n    # links to third party pages see:\nhttps://en.wikipedia.org/wiki/Wikipedia:Protocol-relative_URL\n\
    \    if value.startswith('//'):\n        return bad_link\n\n    # Only allow relative\
    \ links\n    # if you want to allow links that start with http or ws replace with\
    \ below:\n    # if not value.startswith('/'): and not value.startswith('http')\
    \ and not\nvalue.startswith('ws')\n    if not value.startswith('/'):\n       \
    \ return bad_link\n\n    # Alternatively, you could only call escape if autoescape\
    \ is true\n    # if eval_ctx.autoescape:\n    #    return escape(value)\n    #\
    \ else\n    #    return value\n\n    return escape(value)\n\n# Create a replacement\
    \ table\njs_replacement = str.maketrans({\n        '\"':  \"\\\\u0022\",\n   \
    \     '`':  \"\\\\u0060\",\n        '&':  \"\\\\u0026\",\n        '\\'': \"\\\\\
    u0027\",\n        '+':  \"\\\\u002b\",\n        '/':  \"\\\\/\",\n        '<':\
    \  \"\\\\u003c\",\n        '>':  \"\\\\u003e\",\n        '\\\\': \"\\\\\\\\\"\
    ,\n        '(': \"\\\\u0028\",\n        ')': \"\\\\u0029\",\n    })\n\n@pass_eval_context\n\
    def escape_js(eval_ctx, value):\n    \"\"\"\n    Escape the input for use in <script>\
    \ context, USE WITH CAUTION\n    It is strongly recommended to _never_ pass user-supplied\
    \ input to\n    the JavaScript context. This may still be unsafe depending where\n\
    \    used, it does not consider characters used  in regular expressions\n    for\
    \ example.\n    \"\"\"\n\n    #if eval_ctx.autoescape:\n    #    value = escape(value)\n\
    \    # Escape by default\n    value = escape(value)\n    # Translate any potential\
    \ characters using our translation table\n    return value.translate(js_replacement)\n\
    \n# Create our environment, setting autoescape to use the default\n# select_autoescape\
    \ function\nenv = Environment(\n    loader=FileSystemLoader(os.getcwd()+\"/template\"\
    ),\n    autoescape=select_autoescape,\n)\n# Add an escape link filter to be used\
    \ in our template\nenv.filters[\"escape_link\"] = escape_link\nenv.filters[\"\
    escape_js\"] = escape_js\n# Load our template file\ntemplate = env.get_template(\"\
    mytemplate.html\")\n# Render with different variables which call our filters\n\
    print(template.render(\n    html_context=\"<img src=x onerror=alert(1)>\",\n \
    \   link_context=\"/# onclick=alert(1)<script>alert(1)</script>\",\n    script_context=\"\
    alert(1);alert`1`\",)\n)\n\n# Sample template:\n\"\"\"\n<!DOCTYPE html>\n<html\
    \ lang=\"en\">\n<head>\n    <title>My Webpage</title>\n</head>\n<body>\n    <h1>My\
    \ Webpage</h1>\n    {{ html_context }}\n    <a href=\"{{ link_context | escape_link\
    \ }}\">link</a>\n    <script>{{ script_context | escape_js }}</script>\n</body>\n\
    </html>\n\"\"\"\n```\n\nFor more information on autoescape see:\n- https://jinja.palletsprojects.com/en/3.1.x/api/#autoescaping\n\
    \nFor more information on XSS see OWASP:\n- https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html\n"
  metadata:
    category: security
    cwe: CWE-116
    owasp:
    - A7:2017-Cross-Site Scripting (XSS)
    - A03:2021-Injection
    security-severity: Medium
    shortDescription: Improper encoding or escaping of output
  patterns:
  - pattern-not: jinja2.Environment(..., autoescape=True, ...)
  - pattern-not: jinja2.Environment(..., autoescape=jinja2.select_autoescape(...),
      ...)
  - pattern: jinja2.Environment(...)
  severity: WARNING
- id: python_urlopen_rule-urllib-urlopen
  languages:
  - python
  message: 'The application was found passing in a non-literal value to the `urllib`
    methods which issue

    requests. `urllib` supports the `file://` scheme, which may allow an adversary
    who can control

    the URL value to read arbitrary files on the file system.


    To remediate this issue either hardcode the URLs being used in urllib or use the
    `requests`

    module instead.


    Example using the `requests` module to issue an HTTPS request:

    ```

    import requests

    # Issue a GET request to https://example.com with a timeout of 10 seconds

    response = requests.get(''https://example.com'', timeout=10)

    # Work with the response object

    # ...

    ```

    '
  metadata:
    category: security
    cwe: CWE-939
    owasp:
    - A1:2017-Injection
    - A03:2021-Injection
    security-severity: Medium
    shortDescription: Improper authorization in handler for custom URL scheme
  patterns:
  - pattern-either:
    - patterns:
      - pattern-either:
        - pattern: urllib.$METHOD(...)
        - pattern: urllib.request.$METHOD(...)
      - pattern-not: urllib.$METHOD("...")
      - pattern-not: urllib.request.$METHOD("...")
      - pattern-not: urllib.$METHOD("...", ...)
      - pattern-not: urllib.request.$METHOD("...", ...)
      - metavariable-regex:
          metavariable: $METHOD
          regex: (urlopen|urlretrieve)
    - patterns:
      - pattern-either:
        - pattern-inside: '$OPENER = urllib.URLopener(...)

            ...

            '
        - pattern-inside: '$OPENER = urllib.request.URLopener(...)

            ...

            '
        - pattern-inside: '$OPENER = urllib.FancyURLopener(...)

            ...

            '
        - pattern-inside: '$OPENER = urllib.request.FancyURLopener(...)

            ...

            '
      - pattern-either:
        - pattern: $OPENER.open(...)
        - pattern: $OPENER.retrieve(...)
      - pattern-not: $OPENER.open("...")
      - pattern-not: $OPENER.retrieve("...")
  severity: WARNING
- id: python_bind-all-interfaces_rule-general-bindall-interfaces
  languages:
  - python
  message: 'Binding to all network interfaces can potentially open up a service to

    traffic on unintended interfaces, that may not be properly documented or

    secured. By passing "0.0.0.0", "::" or an empty string as the address to the `socket.bind`

    function,

    the application will bind to all interfaces.


    Consider passing in the interface ip address through an environment variable,

    configuration file, or by determining the primary interface(s) IP address.


    Example getting the IP address from an environment variable `IP_ADDRESS`:

    ```

    # Get the IP_ADDRESS env variable, or bind to

    # 127.0.0.1 if it is not set

    address = os.getenv("IP_ADDRESS", "127.0.0.1")

    # Create an internet socket

    sock = socket.socket(socket.AF_INET)

    # Set the port to listen on

    port = 9777

    # Bind to the address and port combination

    sock.bind((address, port))

    # Listen for connections

    sock.listen()

    # Handle the connection

    ```

    '
  metadata:
    category: security
    cwe: CWE-200
    owasp:
    - A6:2017-Security Misconfiguration
    - A05:2021-Security Misconfiguration
    security-severity: Low
    shortDescription: Exposure of sensitive information to an unauthorized actor
  patterns:
  - pattern-either:
    - pattern: '$S = socket.socket(...)

        ...

        $S.bind(("0.0.0.0", ...))

        '
    - pattern: '$S = socket.socket(...)

        ...

        $S.bind(("::", ...))

        '
    - pattern: '$S = socket.socket(...)

        ...

        $S.bind(("", ...))

        '
  severity: INFO
- id: python_assert_rule-assert-used
  languages:
  - python
  message: "The application was found using `assert` in non-test code. Usually reserved\
    \ for debug and test\ncode, the `assert`\nfunction is commonly used to test conditions\
    \ before continuing execution. However, enclosed\ncode will be removed\nwhen compiling\
    \ Python code to optimized byte code. Depending on the assertion and subsequent\n\
    logic, this could\nlead to undefined behavior of the application or application\
    \ crashes.\n\nTo remediate this issue, remove the `assert` calls. If necessary,\
    \ replace them with either `if`\nconditions or\n`try/except` blocks.\n\nExample\
    \ using `try/except` instead of `assert`:\n```\n# Below try/except is equal to\
    \ the assert statement of:\n# assert user.is_authenticated(), \"user must be authenticated\"\
    \ntry:\n    if not user.is_authenticated():\n        raise AuthError(\"user must\
    \ be authenticated\")\nexcept AuthError as e:\n    # Handle error\n    # ...\n\
    \    # Return, do not continue processing\n    return\n```\n"
  metadata:
    category: security
    cwe: CWE-754
    owasp:
    - A6:2017-Security Misconfiguration
    - A05:2021-Security Misconfiguration
    security-severity: Info
    shortDescription: Improper check for unusual or exceptional conditions
  patterns:
  - pattern: assert(...)
  - pattern-not-inside: 'import pytest

      ...

      '
  - pattern-not-inside: 'import unittest

      ...

      '
  severity: INFO
- id: python_xml_rule-pulldom
  languages:
  - python
  message: "The application was found using the `xml.dom.pulldom` package for processing\
    \ XML. Python's\ndefault XML processors suffer from various XML parsing vulnerabilities\n\
    and care must be taken when handling XML data. Additionally, depending on the\n\
    version of Python, more critical vulnerabilities such as eXternal XML Entity\n\
    injection maybe exploitable.\n\nThe `xml.dom.pulldom` package suffers from the\
    \ following security risks as of Python 3.7.1:\n* Billion laughs / exponential\
    \ entity expansion - May allow an adversary to cause\n  a Denial of Service (DoS)\
    \ against the application parsing arbitrary XML.\n* Quadratic blowup entity expansion\
    \ - Similar to above, but requires a larger input\n  to cause the Denial of Service.\n\
    \nTo remediate the above issues, consider using the\n[defusedxml](https://pypi.org/project/defusedxml/)\n\
    library when processing untrusted XML.\n\nExample parsing an XML document using\
    \ defusedxml:\n```\nfrom defusedxml.ElementTree import parse\n\n# Parse the inventory.xml\
    \ file\net = parse('inventory.xml')\n# Get the root element\nroot = et.getroot()\n\
    # Work with the root element\n# ...\n```\n\nFor more information on the various\
    \ XML parsers and their vulnerabilities please see:\n- https://docs.python.org/3/library/xml.html#xml-vulnerabilities\n\
    \nFor more information on XML security see OWASP's guide:\n- https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#python\n"
  metadata:
    category: security
    cwe: CWE-611
    owasp:
    - A4:2017-XML External Entities (XXE)
    - A03:2021-Injection
    security-severity: Medium
    shortDescription: Improper restriction of XML external entity reference
  pattern-either:
  - patterns:
    - pattern: xml.dom.pulldom.parseString(...)
    - pattern-not: xml.dom.pulldom.parseString("...")
  - pattern: xml.dom.pulldom.parse(...)
  severity: WARNING
- id: python_xml_rule-expatreader
  languages:
  - python
  message: "The application was found using the `xml.sax.expatreader` package for\
    \ processing XML. Python's\ndefault XML processors suffer from various XML parsing\
    \ vulnerabilities\nand care must be taken when handling XML data. Additionally,\
    \ depending on the\nversion of Python, more critical vulnerabilities such as eXternal\
    \ XML Entity\ninjection maybe exploitable.\n\nThe `xml.sax` package suffers from\
    \ the following security risks as of Python 3.7.1:\n* Billion laughs / exponential\
    \ entity expansion - May allow an adversary to cause\n  a Denial of Service (DoS)\
    \ against the application parsing arbitrary XML.\n* Quadratic blowup entity expansion\
    \ - Similar to above, but requires a larger input\n  to cause the Denial of Service.\n\
    \nTo remediate the above issues, consider using the\n[defusedxml](https://pypi.org/project/defusedxml/)\n\
    library when processing untrusted XML.\n\nExample parsing an XML document using\
    \ defusedxml:\n```\nfrom defusedxml.ElementTree import parse\n\n# Parse the inventory.xml\
    \ file\net = parse('inventory.xml')\n# Get the root element\nroot = et.getroot()\n\
    # Work with the root element\n# ...\n```\n\nFor more information on the various\
    \ XML parsers and their vulnerabilities please see:\n- https://docs.python.org/3/library/xml.html#xml-vulnerabilities\n\
    \nFor more information on XML security see OWASP's guide:\n- https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#python\n"
  metadata:
    category: security
    cwe: CWE-611
    owasp:
    - A4:2017-XML External Entities (XXE)
    - A03:2021-Injection
    security-severity: Medium
    shortDescription: Improper restriction of XML external entity reference
  pattern-either:
  - pattern: xml.dom.expatreader.parse(...)
  - patterns:
    - pattern: xml.dom.expatreader.parseString(...)
    - pattern-not: xml.dom.expatreader.parseString("...")
  - pattern: xml.dom.expatreader.parseString(...)
  - pattern: xml.dom.expatreader.create_parser(...)
  severity: WARNING
- id: python_xml_rule-expatbuilder
  languages:
  - python
  message: "The application was found using the `xml.dom.expatbuilder` which calls\
    \ the `xml.dom.minidom`\npackage for processing XML. Python's default XML processors\
    \ suffer from various XML parsing\nvulnerabilities\nand care must be taken when\
    \ handling XML data. Additionally, depending on the\nversion of Python, more critical\
    \ vulnerabilities such as eXternal XML Entity\ninjection maybe exploitable.\n\n\
    The `xml.dom.minidom` package suffers from the following security risks as of\
    \ Python 3.7.1:\n* Billion laughs / exponential entity expansion - May allow an\
    \ adversary to cause\n  a Denial of Service (DoS) against the application parsing\
    \ arbitrary XML.\n* Quadratic blowup entity expansion - Similar to above, but\
    \ requires a larger input\n  to cause the Denial of Service.\n\nTo remediate the\
    \ above issues, consider using the\n[defusedxml](https://pypi.org/project/defusedxml/)\n\
    library when processing untrusted XML.\n\nExample parsing an XML document using\
    \ defusedxml:\n```\nfrom defusedxml.ElementTree import parse\n\n# Parse the inventory.xml\
    \ file\net = parse('inventory.xml')\n# Get the root element\nroot = et.getroot()\n\
    # Work with the root element\n# ...\n```\n\nFor more information on the various\
    \ XML parsers and their vulnerabilities please see:\n- https://docs.python.org/3/library/xml.html#xml-vulnerabilities\n\
    \nFor more information on XML security see OWASP's guide:\n- https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#python\n"
  metadata:
    category: security
    cwe: CWE-611
    owasp:
    - A4:2017-XML External Entities (XXE)
    - A03:2021-Injection
    security-severity: Medium
    shortDescription: Improper restriction of XML external entity reference
  pattern-either:
  - patterns:
    - pattern: xml.dom.expatbuilder.parse(...)
    - pattern-not: xml.dom.expatbuilder.parse("...")
  - pattern: xml.dom.expatbuilder.parseString(...)
  severity: WARNING
- id: python_xml_rule-element
  languages:
  - python
  message: "The application was found using the `xml.etree` package for processing\
    \ XML.\nPythons default xml processors suffer from various XML parsing vulnerabilities\n\
    and care must be taken when handling XML data. Additionally, depending on the\n\
    version of Python, more critical vulnerabilities such as eXternal XML Entity\n\
    injection maybe exploitable.\n\nThe `etree` package suffers from the following\
    \ security risks as of Python 3.7.1:\n* Billion laughs / exponential entity expansion\
    \ - May allow an adversary to cause\n  a Denial of Service (DoS) against the application\
    \ parsing arbitrary XML.\n* Quadratic blowup entity expansion - Similar to above,\
    \ but requires a larger input\n  to cause the Denial of Service.\n\nTo remediate\
    \ the above issues, consider using the\n[defusedxml](https://pypi.org/project/defusedxml/)\n\
    library when processing untrusted XML.\n\nExample parsing an XML document using\
    \ defusedxml:\n```\nfrom defusedxml.ElementTree import parse\n\n# Parse the inventory.xml\
    \ file\net = parse('inventory.xml')\n# Get the root element\nroot = et.getroot()\n\
    # Work with the root element\n# ...\n```\n\nFor more information on the various\
    \ XML parsers and their vulnerabilities please see:\n- https://docs.python.org/3/library/xml.html#xml-vulnerabilities\n\
    \nFor more information on XML security see OWASP's guide:\n- https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#python\n"
  metadata:
    category: security
    cwe: CWE-611
    owasp:
    - A4:2017-XML External Entities (XXE)
    - A03:2021-Injection
    security-severity: Medium
    shortDescription: Improper restriction of XML external entity reference
  pattern-either:
  - patterns:
    - pattern: xml.etree.ElementTree.fromstring(...)
    - pattern-not: xml.etree.ElementTree.fromstring("...")
  - pattern: xml.etree.ElementTree.parse(...)
  - pattern: xml.etree.ElementTree.iterparse(...)
  - pattern: xml.etree.ElementTree.XMLParser(...)
  severity: WARNING
- id: python_xml_rule-etree
  languages:
  - python
  message: "The application was found using the `lxml.etree` package for processing\
    \ XML.\nPython's default XML processors suffer from various XML parsing vulnerabilities\n\
    and care must be taken when handling XML data. Additionally, depending on the\n\
    version of Python, more critical vulnerabilities such as eXternal XML Entity\n\
    injection maybe exploitable.\n\nThe `etree` package suffers from the following\
    \ security risks as of Python 3.7.1:\n* Billion laughs / exponential entity expansion\
    \ - May allow an adversary to cause\n  a Denial of Service (DoS) against the application\
    \ parsing arbitrary XML.\n* Quadratic blowup entity expansion - Similar to above,\
    \ but requires a larger input\n  to cause the Denial of Service.\n\nTo remediate\
    \ the above issues, consider using the\n[defusedxml](https://pypi.org/project/defusedxml/)\n\
    library when processing untrusted XML.\n\nExample parsing an XML document using\
    \ defusedxml:\n```\nfrom defusedxml.ElementTree import parse\n\n# Parse the inventory.xml\
    \ file\net = parse('inventory.xml')\n# Get the root element\nroot = et.getroot()\n\
    # Work with the root element\n# ...\n```\n\nFor more information on the various\
    \ XML parsers and their vulnerabilities please see:\n- https://docs.python.org/3/library/xml.html#xml-vulnerabilities\n\
    \nFor more information on XML security see OWASP's guide:\n- https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#python\n"
  metadata:
    category: security
    cwe: CWE-611
    owasp:
    - A4:2017-XML External Entities (XXE)
    - A03:2021-Injection
    security-severity: Medium
    shortDescription: Improper restriction of XML external entity reference
  pattern-either:
  - pattern: lxml.etree.parse(...)
  - patterns:
    - pattern: lxml.etree.fromstring(...)
    - pattern-not: lxml.etree.fromstring("...")
  - pattern: lxml.etree.RestrictedElement(...)
  - pattern: lxml.etree.GlobalParserTLS(...)
  - pattern: lxml.etree.getDefaultParser(...)
  - pattern: lxml.etree.check_docinfo(...)
  severity: WARNING
- id: python_xml_rule-celement
  languages:
  - python
  message: "The application was found using the `xml.etree` package for processing\
    \ XML.\nPythons default xml processors suffer from various XML parsing vulnerabilities\n\
    and care must be taken when handling XML data. Additionally, depending on the\n\
    version of Python, more critical vulnerabilities such as eXternal XML Entity\n\
    injection maybe exploitable.\n\nThe `etree` package suffers from the following\
    \ security risks as of Python 3.7.1:\n* Billion laughs / exponential entity expansion\
    \ - May allow an adversary to cause\n  a Denial of Service (DoS) against the application\
    \ parsing arbitrary XML.\n* Quadratic blowup entity expansion - Similar to above,\
    \ but requires a larger input\n  to cause the Denial of Service.\n\nTo remediate\
    \ the above issues, consider using the\n[defusedxml](https://pypi.org/project/defusedxml/)\n\
    library when processing untrusted XML.\n\nExample parsing an XML document using\
    \ defusedxml:\n```\nfrom defusedxml.ElementTree import parse\n\n# Parse the inventory.xml\
    \ file\net = parse('inventory.xml')\n# Get the root element\nroot = et.getroot()\n\
    # Work with the root element\n# ...\n```\n\nFor more information on the various\
    \ XML parsers and their vulnerabilities please see:\n- https://docs.python.org/3/library/xml.html#xml-vulnerabilities\n\
    \nFor more information on XML security see OWASP's guide:\n- https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#python\n"
  metadata:
    category: security
    cwe: CWE-611
    owasp:
    - A4:2017-XML External Entities (XXE)
    - A03:2021-Injection
    security-severity: Medium
    shortDescription: Improper restriction of XML external entity reference
  pattern-either:
  - patterns:
    - pattern: xml.etree.cElementTree.fromstring(...)
    - pattern-not: xml.etree.cElementTree.fromstring("...")
  - pattern: xml.etree.cElementTree.parse(...)
  - pattern: xml.etree.cElementTree.iterparse(...)
  - pattern: xml.etree.cElementTree.XMLParser(...)
  severity: WARNING
- id: python_xml_rule-sax
  languages:
  - python
  message: "The application was found using the `xml.sax` package for processing XML.\n\
    Python's default XML processors suffer from various XML parsing vulnerabilities\n\
    and care must be taken when handling XML data. Additionally, depending on the\n\
    version of Python, more critical vulnerabilities such as eXternal XML Entity\n\
    injection maybe exploitable.\n\nThe `xml.sax` package suffers from the following\
    \ security risks as of Python 3.7.1:\n* Billion laughs / exponential entity expansion\
    \ - May allow an adversary to cause\n  a Denial of Service (DoS) against the application\
    \ parsing arbitrary XML.\n* Quadratic blowup entity expansion - Similar to above,\
    \ but requires a larger input\n  to cause the Denial of Service.\n\nTo remediate\
    \ the above issues, consider using the\n[defusedxml](https://pypi.org/project/defusedxml/)\n\
    library when processing untrusted XML.\n\nExample parsing an XML document using\
    \ defusedxml:\n```\nfrom defusedxml.ElementTree import parse\n\n# Parse the inventory.xml\
    \ file\net = parse('inventory.xml')\n# Get the root element\nroot = et.getroot()\n\
    # Work with the root element\n# ...\n```\n\nFor more information on the various\
    \ XML parsers and their vulnerabilities please see:\n- https://docs.python.org/3/library/xml.html#xml-vulnerabilities\n\
    \nFor more information on XML security see OWASP's guide:\n- https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#python\n"
  metadata:
    category: security
    cwe: CWE-611
    owasp:
    - A4:2017-XML External Entities (XXE)
    - A03:2021-Injection
    security-severity: Medium
    shortDescription: Improper restriction of XML external entity reference
  pattern-either:
  - pattern: xml.sax.parse(...)
  - patterns:
    - pattern: xml.sax.parseString(...)
    - pattern-not: xml.sax.parseString("...")
  - pattern: xml.sax.make_parser(...)
  severity: WARNING
- id: python_xml_rule-minidom
  languages:
  - python
  message: "The application was found using the `xml.dom.minidom` package for processing\
    \ XML. Python's\ndefault XML processors suffer from various XML parsing vulnerabilities\n\
    and care must be taken when handling XML data. Additionally, depending on the\n\
    version of Python, more critical vulnerabilities such as eXternal XML Entity\n\
    injection maybe exploitable.\n\nThe `xml.dom.minidom` package suffers from the\
    \ following security risks as of Python 3.7.1:\n* Billion laughs / exponential\
    \ entity expansion - May allow an adversary to cause\n  a Denial of Service (DoS)\
    \ against the application parsing arbitrary XML.\n* Quadratic blowup entity expansion\
    \ - Similar to above, but requires a larger input\n  to cause the Denial of Service.\n\
    \nTo remediate the above issues, consider using the\n[defusedxml](https://pypi.org/project/defusedxml/)\n\
    library when processing untrusted XML.\n\nExample parsing an XML document using\
    \ defusedxml:\n```\nfrom defusedxml.ElementTree import parse\n\n# Parse the inventory.xml\
    \ file\net = parse('inventory.xml')\n# Get the root element\nroot = et.getroot()\n\
    # Work with the root element\n# ...\n```\n\nFor more information on the various\
    \ XML parsers and their vulnerabilities please see:\n- https://docs.python.org/3/library/xml.html#xml-vulnerabilities\n\
    \nFor more information on XML security see OWASP's guide:\n- https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#python\n"
  metadata:
    category: security
    cwe: CWE-611
    owasp:
    - A4:2017-XML External Entities (XXE)
    - A03:2021-Injection
    security-severity: Medium
    shortDescription: Improper restriction of XML external entity reference
  pattern-either:
  - patterns:
    - pattern: xml.dom.minidom.parseString(...)
    - pattern-not: xml.dom.minidom.parseString("...")
  - pattern: xml.dom.minidom.parse(...)
  severity: WARNING
- id: python_requests_rule-request-without-timeout
  languages:
  - python
  message: 'The application was found using the `requests` module without configuring
    a timeout value for

    connections. This could lead to uncontrolled resource consumption where the application
    could

    run out of

    socket descriptors, effectively causing a Denial of Service (DoS).


    To remediate this issue, pass in a `timeout=` argument to each `requests` call.


    Example using a timeout for an HTTP GET request:

    ```

    # Issue a GET request to https://example.com with a timeout of 10 seconds

    response = requests.get(''https://example.com'', timeout=10)

    # Work with the response object

    # ...

    ```


    For more information on using the requests module see:

    - https://requests.readthedocs.io/en/latest/api/

    '
  metadata:
    category: security
    cwe: CWE-400
    owasp:
    - A6:2017-Security Misconfiguration
    - A05:2021-Security Misconfiguration
    security-severity: Medium
    shortDescription: Uncontrolled resource consumption
  patterns:
  - pattern-either:
    - patterns:
      - pattern: requests.$METHOD(..., timeout=$VAL, ...)
      - metavariable-comparison:
          comparison: $VAL <= 0
          metavariable: $VAL
    - patterns:
      - pattern: requests.$METHOD(..., timeout=$VAL, ...)
      - metavariable-regex:
          metavariable: $VAL
          regex: (^None)
    - patterns:
      - pattern-not: requests.$METHOD(..., timeout=$VAL, ...)
      - pattern-either:
        - pattern: requests.$METHOD(..., ...)
        - pattern: requests.$METHOD(...)
  - metavariable-regex:
      metavariable: $METHOD
      regex: (get|put|delete|post|options|head|patch)
  severity: WARNING
- id: python_ssh_rule-ssh-nohost-key-verification
  languages:
  - python
  message: "The application was found to ignore host keys. Host keys are important\
    \ as\nthey provide assurance that the client can prove that the host is trusted.\n\
    By ignoring these host keys, it is impossible for the client to validate the\n\
    connection is to a trusted host.\n\nTo remediate this issue, remove the call to\
    \ `set_missing_host_key_policy(...)` which\nsets the host key policy. Instead,\
    \ load key files using either `load_system_host_keys`\nor `load_host_keys` to\
    \ only allow known good hosts. By not setting a host key policy\nfor unknown hosts,\
    \ `paramiko`'s default policy is to use `RejectPolicy`.\n\nExample configuration\
    \ connecting to a known, trusted host, and not allowing connections\nto unknown\
    \ hosts:\n```\nimport paramiko\n\n# Create an SSH client\nwith paramiko.SSHClient()\
    \ as ssh:\n    # Load the system host keys so we can confirm the\n    # host we\
    \ are connecting to is legitimate\n    ssh.load_system_host_keys('/home/appuser/.ssh/known_hosts')\n\
    \n    # Connect to the remote host using our SSH private key\n    ssh.connect(hostname='example.org',\n\
    \                port=22,\n                username='appuser',\n             \
    \   key_filename='/home/appuser/.ssh/private_key')\n```\n\nFor more information\
    \ on `set_missing_host_key_policy` see:\n- https://docs.paramiko.org/en/stable/api/client.html#paramiko.client.SSHClient.set_missing_host_key_policy\n"
  metadata:
    category: security
    cwe: CWE-322
    owasp:
    - A5:2017-Broken Access Control
    - A07:2021-Identification and Authentication Failures
    security-severity: Medium
    shortDescription: Key exchange without entity authentication
  patterns:
  - pattern-inside: '$CLIENT = paramiko.client.SSHClient(...)

      ...

      $CLIENT.set_missing_host_key_policy(...)

      '
  - pattern-either:
    - pattern: paramiko.client.AutoAddPolicy
    - pattern: paramiko.client.WarningPolicy
  severity: ERROR
- id: python_tmpdir_rule-mktemp-q
  languages:
  - python
  message: "The application was found creating temporary files with the insecure `mktemp`\
    \ method.\nDepending on how the application uses this temporary file, an attacker\
    \ may be able to create\nsymlinks that point to other files prior to the application\
    \ creating or writing\nto the target file, leading to unintended files being created\
    \ or overwritten.\n\nTo remediate this issue consider using `tempfile.TemporaryFile`\
    \ instead.\n\nExample using `tempfile.TemporaryFile` to write a file:\n```\nimport\
    \ tempfile\n\n# Open a new temporary file using a context manager\nwith tempfile.TemporaryFile()\
    \ as fp:\n    # Write some data to the temporary file\n    fp.write(b'Some data')\n\
    \    # Seek back to beginning of file\n    fp.seek(0)\n    # Read it\n    data\
    \ = fp.read()\n# File is automatically closed/removed once we exit the with context\n\
    ```\n\nFor more information on alternative tempfile functions see:\n- https://docs.python.org/3/library/tempfile.html\n"
  metadata:
    category: security
    cwe: CWE-377
    owasp:
    - A3:2017-Sensitive Data Exposure
    - A01:2021-Broken Access Control
    security-severity: Medium
    shortDescription: Insecure temporary file
  pattern: tempfile.mktemp(...)
  severity: ERROR
- id: python_tmpdir_rule-hardcodedtmp
  languages:
  - python
  message: "The application was found creating files in shared system temporary directories\n\
    (`/tmp` or `/var/tmp`) without using the `tempfile.TemporaryFile` function. Depending\n\
    on how the application uses this temporary file, an attacker may be able to create\n\
    symlinks that point to other files prior to the application creating or writing\n\
    to the target file, leading to unintended files being created or overwritten.\n\
    \nExample using `tempfile.TemporaryFile` to write a file:\n```\nimport tempfile\n\
    \n# Open a new temporary file using a context manager\nwith tempfile.TemporaryFile()\
    \ as fp:\n    # Write some data to the temporary file\n    fp.write(b'Some data')\n\
    \    # Seek back to beginning of file\n    fp.seek(0)\n    # Read it\n    data\
    \ = fp.read()\n# File is automatically closed/removed once we exit the with context\n\
    ```\n\nFor more information on alternative tempfile functions see:\n- https://docs.python.org/3/library/tempfile.html\n"
  metadata:
    category: security
    cwe: CWE-377
    owasp:
    - A5:2017-Broken Access Control
    - A01:2021-Broken Access Control
    security-severity: Medium
    shortDescription: Insecure temporary file
  pattern: $CALL("=~/^\/tmp.*/", ...)
  severity: WARNING
- id: python_exec_rule-subprocess-call
  languages:
  - python
  message: 'Python possesses many mechanisms to invoke an external executable. However,

    doing so may present a security issue if appropriate care is not taken to

    sanitize any user provided or variable input. This plugin test is part of a

    family of tests built to check for process spawning and warn appropriately.

    Specifically, this test looks for the spawning of a subprocess without the

    use of a command shell. This type of subprocess invocation is not

    vulnerable to shell injection attacks, but care should still be taken to

    ensure validity of input.

    '
  metadata:
    category: security
    cwe: CWE-78
    owasp:
    - A1:2017-Injection
    - A03:2021-Injection
    security-severity: High
    shortDescription: Improper neutralization of special elements used in an OS Command
      ('OS Command Injection')
  patterns:
  - pattern-not: subprocess.$FUNC($ARG, shell=<... True ...>)
  - pattern-not: subprocess.$FUNC($ARG, shell=<... 'True' ...>)
  - pattern-not: subprocess.$FUNC($ARG, shell=<... "True" ...>)
  - pattern-either:
    - pattern: 'subprocess.$FUNC($ARG, shell=False)

        '
    - pattern: 'subprocess.$FUNC($ARG, shell=0)

        '
    - pattern: 'subprocess.$FUNC($ARG, shell={...})

        '
    - pattern: 'subprocess.$FUNC($ARG, shell=[...])

        '
    - pattern: 'subprocess.$FUNC($ARG)

        '
  severity: WARNING
- id: python_exec_rule-os-path
  languages:
  - python
  message: 'Starting a process with a shell; seems safe, but may be changed in the
    future, consider

    rewriting without shell

    '
  metadata:
    category: security
    cwe: CWE-78
    owasp:
    - A1:2017-Injection
    - A03:2021-Injection
    security-severity: High
    shortDescription: Improper neutralization of special elements used in an OS Command
      ('OS Command Injection')
  pattern-either:
  - pattern: os.system("...", ...)
  - pattern: $OS.popen("...", ...)
  - pattern: $OS.popen2("...", ...)
  - pattern: $OS.popen3("...", ...)
  - pattern: $OS.popen4("...", ...)
  - pattern: commands.getoutput("...", ...)
  - pattern: commands.getstatusoutput("...", ...)
  severity: INFO
- id: python_exec_rule-start-process-with-no-shell
  languages:
  - python
  message: 'Found dynamic content when spawning a process. This is dangerous if externaldata
    can reach this

    function call because it allows a malicious actor toexecute commands. Ensure no
    external data

    reaches here.

    '
  metadata:
    category: security
    cwe: CWE-78
    owasp:
    - A1:2017-Injection
    - A03:2021-Injection
    security-severity: High
    shortDescription: Improper neutralization of special elements used in an OS Command
      ('OS Command Injection')
  patterns:
  - pattern-either:
    - patterns:
      - pattern-not: os.$W("...", ...)
      - pattern-either:
        - pattern: os.execl(...)
        - pattern: os.execle(...)
        - pattern: os.execlp(...)
        - pattern: os.execlpe(...)
        - pattern: os.execv(...)
        - pattern: os.execve(...)
        - pattern: os.execvp(...)
        - pattern: os.execvpe(...)
        - pattern: os.startfile(...)
    - patterns:
      - pattern-either:
        - pattern: os.spawnl(...)
        - pattern: os.spawnle(...)
        - pattern: os.spawnlp(...)
        - pattern: os.spawnlpe(...)
        - pattern: os.spawnv(...)
        - pattern: os.spawnve(...)
        - pattern: os.spawnvp(...)
        - pattern: os.spawnvpe(...)
  severity: WARNING
- id: python_exec_rule-subprocess-popen-shell-true
  languages:
  - python
  message: 'Found `subprocess` function `$FUNC` with `shell=True`. This is dangerous
    because this call will

    spawn the command using a shell process. Doing so propagates current shell settings
    and

    variables,

    which makes it much easier for a malicious actor to execute commands. Use `shell=False`

    instead.

    '
  metadata:
    category: security
    cwe: CWE-78
    owasp:
    - A1:2017-Injection
    - A03:2021-Injection
    security-severity: High
    shortDescription: Improper neutralization of special elements used in an OS Command
      ('OS Command Injection')
  patterns:
  - patterns:
    - pattern-not-inside: '...

        $ARG = ''...''.format(''...'')

        ...

        '
    - pattern: subprocess.$FUNC($ARG, ...)
    - pattern-not: subprocess.$FUNC('...', ...)
    - pattern-not: subprocess.$FUNC('...' % '...', ...)
    - pattern-not: subprocess.$FUNC('...'.format('...'), ...)
  - pattern-either:
    - pattern: subprocess.$FUNC(..., shell=True, ...)
    - pattern: subprocess.$FUNC(..., shell=[$V, ...], ...)
    - pattern: 'subprocess.$FUNC(..., shell={$K: $V, ...}, ...)'
    - patterns:
      - pattern: subprocess.$FUNC(..., shell=$INTVAL, ...)
      - pattern-not: subprocess.$FUNC(..., shell=0, ...)
      - metavariable-regex:
          metavariable: $INTVAL
          regex: ^[0-9]+$
    - patterns:
      - pattern: subprocess.$FUNC(..., shell='$STRVAL', ...)
      - pattern-not: subprocess.$FUNC(..., shell='', ...)
  severity: ERROR
- id: python_exec_rule-subprocess-shell-TRUE
  languages:
  - python
  message: 'subprocess call - check for execution of untrusted input

    '
  metadata:
    category: security
    cwe: CWE-78
    owasp:
    - A1:2017-Injection
    - A03:2021-Injection
    security-severity: High
    shortDescription: Improper neutralization of special elements used in an OS Command
      ('OS Command Injection')
  patterns:
  - pattern-not: subprocess.$FUNC(..., shell=True, ...)
  - pattern: $FOO(..., shell=True, ...)
  severity: WARNING
- id: python_exec_rule-paramiko-calls
  languages:
  - python
  message: 'Unverified SSL context detected. This will permit insecure connections
    without `verifyingSSL`

    certificates. Use `ssl.create_default_context()` instead.

    '
  metadata:
    category: security
    cwe: CWE-78
    owasp:
    - A1:2017-Injection
    - A03:2021-Injection
    security-severity: High
    shortDescription: Improper neutralization of special elements used in an OS Command
      ('OS Command Injection')
  patterns:
  - pattern-inside: 'import paramiko

      ...

      '
  - pattern: $CLIENT.exec_command(...)
  severity: WARNING
- id: python_exec_rule-linux-command-wildcard-injection
  languages:
  - python
  message: "Detected use of the wildcard character in a system call that spawns a\
    \ shell. This subjects the\nwildcard to normal shell expansion, which can have\
    \ unintended consequences if there exist any\nnon-standard file names. For instance,\
    \ a file named `-e sh script.sh` could cause issues when \nexpanded by the shell\
    \ and executed as a command. Consider using a different method to achieve \nthe\
    \ same result, such as using the `glob` module to expand the wildcard before passing\
    \ it to the\nsystem call. Or if the command is static, consider hardcoding the\
    \ command instead of using a\nwildcard.\n\nFor example, the below code uses the\
    \ glob module to expand the wildcard and get a list of all \nCSV files in the\
    \ current directory. This list is then used in the subprocess.run call, instead\
    \ of a \nwildcard. This avoids the potential issues that can arise from using\
    \ a wildcard in a system call.\n```\nimport glob\nimport subprocess\n\n# Secure\
    \ way to process all CSV files\nfiles = glob.glob('*.csv')\nfor file in files:\n\
    \  subprocess.run(['process_data', file])\n```\n"
  metadata:
    category: security
    cwe: CWE-155
    owasp:
    - A1:2017-Injection
    - A03:2021-Injection
    security-severity: High
    shortDescription: Improper neutralization of wildcards or matching symbols
  metavariable-regex:
    X: (system|popen|popen2|popen3|popen4)
  patterns:
  - pattern-either:
    - pattern: os.$X("$CMD", ...)
    - pattern: subprocess.Popen("$CMD", shell=True, ...)
  - metavariable-regex:
      metavariable: $CMD
      regex: (.*?)(\*|\?)
  - pattern-not-inside: os.spawnvp(...)
  severity: WARNING
- id: python_exec_rule-os-popen2
  languages:
  - python
  message: 'Starting a process with a shell; seems safe, but may be changed in the
    future, consider

    rewriting without shell

    '
  metadata:
    category: security
    cwe: CWE-78
    owasp:
    - A1:2017-Injection
    - A03:2021-Injection
    security-severity: High
    shortDescription: Improper neutralization of special elements used in an OS Command
      ('OS Command Injection')
  patterns:
  - pattern-either:
    - pattern: os.system(...)
    - pattern: os.popen(...)
    - pattern: os.popen2(...)
    - pattern: os.popen3(...)
    - pattern: os.popen4(...)
    - pattern: popen2.popen2(...)
    - pattern: popen2.popen3(...)
    - pattern: popen2.popen4(...)
    - pattern: popen2.Popen3(...)
    - pattern: popen2.Popen4(...)
    - pattern: commands.getoutput(...)
    - pattern: commands.getstatusoutput("")
  severity: INFO
- id: python_exec_rule-exec-used
  languages:
  - python
  message: "The application was found calling the `exec` function with a non-literal\
    \ variable. If the\nvariable comes from user-supplied input, an adversary could\
    \ compromise the entire system by\nexecuting arbitrary python code.\n\nTo remediate\
    \ this issue, remove all calls to `exec` and consider alternative methods for\n\
    executing the necessary business logic. There is almost no safe method of calling\
    \ `eval` \nwith user-supplied input.\n\nIf the application only needs to convert\
    \ strings into objects, consider using `json.loads`.\nIn some cases `ast.literal_eval`\
    \ is recommended, but this should be avoided as it can still\nsuffer from other\
    \ issues such as the ability for malicious code to crash the python\ninterpreter\
    \ or application.\n\nExample using `json.loads`` to load in arbitrary data to\
    \ create data structures:\n```\n# User supplied data as a blob of JSON\nuser_supplied_data\
    \ = \"\"\"{\"user\": \"test\", \"metadata\": [1,2,3]}\"\"\"\n# Load the JSON\n\
    user_object = json.loads(user_supplied_data)\n# Manually add protected properties\
    \ _after_ loading, never before\nuser_object[\"is_admin\"] = False\n# Work with\
    \ the object\n```\n"
  metadata:
    category: security
    cwe: CWE-78
    owasp:
    - A1:2017-Injection
    - A03:2021-Injection
    security-severity: High
    shortDescription: Improper neutralization of special elements used in an OS command
      ('OS Command Injection')
  patterns:
  - pattern: exec(...)
  - pattern-not: exec("...")
  severity: WARNING
- id: python_files_rule-tarfile-unsafe-members
  languages:
  - python
  message: "The application may be vulnerable to a path traversal if it extracts untrusted\
    \ archive files.\nThis vulnerability is colloquially known as 'Zip Slip'. Archive\
    \ files may contain folders\nwhich,\nwhen extracted, may write outside of the\
    \ intended directory. This is exploited by including\npath traversal characters\
    \ such as `../../other/directory` to overwrite or place files in system\nor application\
    \ directories.\n\nExtra care must be taken when extracting archive files as there\
    \ are numerous concerns:\n\n- If possible, generate unique filenames instead of\
    \ using the archives file names, as it may be\npossible for users to overwrite\
    \ files if the filenames are the same.\n- Validate file paths are written with\
    \ a prefixed, known trusted directory.\n- Only process regular files and not symbolic\
    \ links, as some applications may attempt to\nread/follow\nthe symbolic link,\
    \ leading to arbitrary file read / write vulnerabilities.\n\nExample of securely\
    \ processing an archive file:\n```\nimport tarfile\nimport uuid\n# import os\n\
    \ntar = tarfile.open('some.tar')\n\n# Max number of allowed files in our archive\n\
    max_files = 10\n# Max size for all files in archive\nmax_size = 1024 * 1024 *\
    \ 10 # 10MB\n# Max size per file in archive\nmax_file_size = 1024 * 1024 # 1MB\n\
    \n# Validate number of files in archive\nif len(tar.getmembers()) > max_files:\n\
    \    raise Exception(\"Too many files in archive\")\n\ntotal_size = 0\n# Loop\
    \ over all files to see if we exceed max size\n# if so, do not process any of\
    \ them.\nfor f in tar.getmembers():\n    total_size += f.size\n    if total_size\
    \ >= max_size:\n        raise Exception(\"Archive files exceeded max file size\"\
    )\n\n# Iterate over files now that we know the total size is within limits\nfor\
    \ f in tar.getmembers():\n    # Internally this calls TarInfo.isreg() which ensures\n\
    \    # the file is a regular file and not a sym link or directory\n    if not\
    \ f.isfile():\n        continue\n\n    # Optional, set a limit on each file size\n\
    \    if f.size > max_file_size:\n        raise Exception(f\"File {f.name} too\
    \ large: {f.size}\")\n\n    # If original names are required, ensure that only\
    \ the\n    # filename is used:\n    # filename = os.path.basename(f.name)\n\n\
    \    # More secure, generate a UUID4 value instead\n    filename = uuid.uuid4().hex\n\
    \n    # Reset the archive filename to the basename\n    # Newer versions of python\
    \ (3.11.4+) should use:\n    # new_tar = old_tar.replace(name=...new name...)\n\
    \    f.name = filename\n\n    # Extract the file into a restricted directory,\
    \ with our\n    # own user's attributes, not the file from the archive\n    tar.extract(f,\
    \ '/opt/app/restricted/', set_attrs=False)\n```\n\nFor more information on tarfile\
    \ see:\n- https://docs.python.org/3/library/tarfile.html\n"
  metadata:
    category: security
    cwe: CWE-22
    owasp:
    - A5:2017-Broken Access Control
    - A01:2021-Broken Access Control
    security-severity: Medium
    shortDescription: Improper limitation of a pathname to a restricted directory
      ('Path Traversal')
  patterns:
  - pattern-inside: 'import tarfile

      ...

      '
  - pattern-either:
    - patterns:
      - pattern-inside: '$TAR = tarfile.open(...)

          ...

          '
      - pattern-either:
        - pattern: $TAR.extractall(...)
        - pattern: tarfile.extractall(..., members=$TAR)
        - pattern: $TAR.extractall(..., members=[])
    - patterns:
      - pattern: tarfile.extractall(...)
      - pattern: tarfile.extractall(..., members=[])
  severity: WARNING
- id: python_log_rule-logging-config-insecure-listen
  languages:
  - python
  message: 'The application was found calling the `logging.config.listen`` function,
    which provides the

    ability to listen for

    external configuration files over a socket server. This listen socket parses part
    of the

    configuration and calls

    `eval` on the supplied configuration file. A local user, or an adversary who is
    able to

    exploit

    a Server Side Request Forgery (SSRF) attack to communicate over localhost, would
    be able to

    execute arbitrary

    code by passing in a logging config that contains python code.


    To remediate the issue, remove the call to `logging.config.listen` method.


    For more information on the listen functionality see:

    - https://docs.python.org/3/library/logging.config.html#logging.config.listen

    '
  metadata:
    category: security
    cwe: CWE-94
    owasp:
    - A1:2017-Injection
    - A03:2021-Injection
    security-severity: High
    shortDescription: Improper control of generation of code ('Code Injection')
  patterns:
  - pattern: logging.config.listen(...)
  severity: WARNING
- id: python_file-permissions_rule-general-bad-permission
  languages:
  - python
  message: 'The application was found setting file permissions to overly permissive
    values. Consider

    using the following values if the application user is the only process to access

    the file:


    - 0400 - read only access to the file

    - 0200 - write only access to the file

    - 0600 - read/write access to the file


    Example creating a file with read/write permissions for the application user:

    ```

    # Use octal values to set 0o600 (read/write access to the file) for the current

    # user

    os.chmod(''somefile.txt'', 0o600)

    ```


    For all other values please see:

    https://en.wikipedia.org/wiki/File-system_permissions#Numeric_notation

    '
  metadata:
    category: security
    cwe: CWE-732
    owasp:
    - A5:2017-Broken Access Control
    - A01:2021-Broken Access Control
    security-severity: Medium
    shortDescription: Incorrect permission assignment for critical resource
  patterns:
  - pattern: os.chmod(...,$MASK)
  - metavariable-regex:
      metavariable: $MASK
      regex: (0x..f|0o..[2,3,7]|stat.S_IXGRP|stat.S_IWOTH)
  severity: WARNING
- id: python_eval_rule-eval
  languages:
  - python
  message: "The application was found calling the `eval` function with non-literal\
    \ data. If the variable contains \nuser-controlled data, either partially or fully,\
    \ an adversary could compromise the entire system by \nexecuting arbitrary Python\
    \ code.\n\nTo remediate this issue, remove all calls to `eval` and consider alternative\
    \ methods for executing \nthe necessary business logic. There is almost no safe\
    \ method of calling `eval` with user-supplied input.\n\nIf the application only\
    \ needs to convert strings into objects, consider using `json.loads`. In \nsome\
    \ cases `ast.literal_eval` is recommended, but this should be avoided as it can\
    \ still suffer \nfrom other issues such as the ability for malicious code to crash\
    \ the python interpreter or application.\n\nExample using `json.loads`` to load\
    \ in arbitrary data to create data structures:\n```\n# User supplied data as a\
    \ blob of JSON\nuser_supplied_data = \"\"\"{\"user\": \"test\", \"metadata\":\
    \ [1,2,3]}\"\"\"\n# Load the JSON\nuser_object = json.loads(user_supplied_data)\n\
    # Manually add protected properties _after_ loading, never before\nuser_object[\"\
    is_admin\"] = False\n# Work with the object\n```\n"
  metadata:
    category: security
    cwe: CWE-95
    owasp:
    - A1:2017-Injection
    - A03:2021-Injection
    security-severity: High
    shortDescription: Improper neutralization of directives in dynamically evaluated
      code ('Eval Injection')
  patterns:
  - pattern: eval($X,...)
  - pattern-not: 'eval("...")

      '
  - pattern-not: 'eval("..." % <... "..." ...>)

      '
  - pattern-not: 'eval(<... "...".format( "..." ) ...>)

      '
  - pattern-not-inside: "def eval(...):\n  ...\n...\n"
  severity: WARNING
- id: python_random_rule-random
  languages:
  - python
  message: 'Depending on the context, generating weak random numbers may expose cryptographic
    functions,

    which rely on these numbers, to be exploitable. When generating numbers for sensitive
    values

    such as tokens, nonces, and cryptographic keys, it is recommended that the `secrets`
    module

    be used instead.


    Example using the secrets module:

    ```

    import secrets


    # Generate a secure random 64 byte array

    random_bytes = secrets.token_bytes(64)

    print(random_bytes)


    # Generate a secure random 64 byte array as a hex string

    random_bytes_hex = secrets.token_hex(64)


    # Generate a secure random 64 byte array base64 encoded for use in URLs

    random_string = secrets.token_urlsafe(64)

    ```


    For more information on the `secrets` module see:

    - https://docs.python.org/3/library/secrets.html

    '
  metadata:
    category: security
    cwe: CWE-330
    owasp:
    - A3:2017-Sensitive Data Exposure
    - A02:2021-Cryptographic Failures
    security-severity: Medium
    shortDescription: Use of insufficiently random values
  pattern-either:
  - pattern: random.random(...)
  - pattern: random.randrange(...)
  - pattern: random.randint(...)
  - pattern: random.choice(...)
  - pattern: random.uniform(...)
  - pattern: random.triangular(...)
  severity: INFO
- id: python_django_rule-django-extra-used
  languages:
  - python
  message: "SQL Injection is a critical vulnerability that can lead to data or system\
    \ compromise. By\ndynamically generating SQL query strings, user input may be\
    \ able to influence the logic of\nthe SQL statement. This could lead to an adversary\
    \ accessing information they should\nnot have access to, or in some circumstances,\
    \ being able to execute OS functionality or code.\n\nReplace all dynamically generated\
    \ SQL queries with parameterized queries. In situations where\ndynamic queries\
    \ must be created, never use direct user input, but instead use a map or\ndictionary\
    \ of valid values and resolve them using a user supplied key.\n\nFor example,\
    \ some database drivers do not allow parameterized queries for `>` or `<` comparison\n\
    operators. In these cases, do not use a user supplied `>` or `<` value, but rather\
    \ have the\nuser\nsupply a `gt` or `lt` value. The alphabetical values are then\
    \ used to look up the `>` and `<`\nvalues to be used in the construction of the\
    \ dynamic query. The same goes for other queries\nwhere\ncolumn or table names\
    \ are required but cannot be parameterized.\n\nThe `QuerySet.extra` API method\
    \ will be deprecated as it a source of SQL Injection\nvulnerabilities and other\
    \ problems. This method is especially risky as callers\nwill need to do their\
    \ own escaping of any parameters that come from user-supplied\ninformation.\n\n\
    To remediate this issue, do not use `extra` but use other `QuerySet` methods to\
    \ achieve\nthe same goals. If for some reason this is not feasible, consider using\
    \ the `RawSQL` method\nand making sure that all arguments, including user-supplied\
    \ ones, are only used in\n`params`\n\n\nWhile not recommended due to [potential\
    \ SQL\nInjection](https://docs.djangoproject.com/en/4.2/ref/models/expressions/#raw-sql-expressions),\n\
    below is an example using `RawSQL`,\npassing in user-supplied data as a `param`\
    \ which will escape the input:\n```\n# If dealing with integer based user input,\
    \ restrict the values to integers only using the\n# path configuration: path('<int:user_supplied_id>/someview/',\
    \ views.some_view,\nname='someview'),\n\n# views.py\ndef some_view(request, user_supplied_id):\n\
    \  # Never use string interpolation in the `sql` parameter.\n  # Never quote the\
    \ `%s` string format such as `... where id='%s'` as this could lead to SQL\nInjection.\n\
    \  # Pass the user supplied data only in the `params` parameter.\n  for obj in\
    \ DBObject.objects.all().annotate(\n      val=RawSQL(sql=\"select id from some_secondary_table\
    \ where id=%s\",\nparams=[user_supplied_id])):\n    # Work with the results from\
    \ the query\n    # ...\n```\n\nFor more information on QuerySet see:\n- https://docs.djangoproject.com/en/4.2/ref/models/querysets/#queryset-api\n\
    \nFor more information on SQL Injection see OWASP:\n- https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html\n"
  metadata:
    category: security
    cwe: CWE-89
    owasp:
    - A1:2017-Injection
    - A03:2021-Injection
    security-severity: High
    shortDescription: Improper neutralization of special elements used in an SQL Command
      ('SQL Injection')
  patterns:
  - pattern: $X.objects. ... .extra(..., $K = $V, ...)
  - pattern-not-inside: '$V = [''...'']

      ...

      '
  - metavariable-pattern:
      metavariable: $V
      patterns:
      - pattern: $V
      - pattern-not: '[..., ''...'', ...]'
      - pattern-not: '{..., ''...'': ''...'', ...}'
      - pattern-not: '"..."'
      - pattern-not: '[..., "..." % "...", ...]'
      - pattern-not: '{..., $L: "..." % "...", ...}'
      - pattern-not: '{..., $L: "...".format("..."), ...}'
      - pattern-not: '[..., "...".format("..."), ...]'
  severity: WARNING
- id: python_telnet_rule-import-telnib
  languages:
  - python
  message: "The application was found using a telnet library. As telnet does not provide\
    \ encryption, it is\nstrongly recommended that communications use a more secure\
    \ transport such as\nSSH.\n\nThe [paramiko](https://www.paramiko.org/) library\
    \ can be used to initiate SSH connections.\n\nExample using `paramiko` SSH client:\n\
    ```\nimport paramiko\nimport scp\n\n# Create an SSH client\nwith paramiko.SSHClient()\
    \ as ssh:\n    # Load the system host keys so we can confirm the\n    # host we\
    \ are connecting to is legitimate\n    ssh.load_system_host_keys('/home/appuser/.ssh/known_hosts')\n\
    \n    # Connect to the remote host using our SSH private key\n    ssh.connect(hostname='example.org',\n\
    \                port=22,\n                username='appuser',\n             \
    \   key_filename='/home/appuser/.ssh/private_key')\n    # Work with the connection\n\
    ```\n\nFor more information on the paramiko module see:\n- https://www.paramiko.org/\n"
  metadata:
    category: security
    cwe: CWE-319
    owasp:
    - A3:2017-Sensitive Data Exposure
    - A02:2021-Cryptographic Failures
    security-severity: Medium
    shortDescription: Cleartext transmission of sensitive information
  patterns:
  - pattern: import telnetlib
  severity: ERROR
- id: python_deserialization_rule-cpickle
  languages:
  - python
  message: "The application was found using `cPickle` which is vulnerable to deserialization\
    \ attacks.\nDeserialization attacks exploit the process of reading serialized\
    \ data and turning it back\ninto an object. By constructing malicious objects\
    \ and serializing them, an adversary may\nattempt to:\n\n- Inject code that is\
    \ executed upon object construction, which occurs during the\ndeserialization\
    \ process.\n- Exploit mass assignment by including fields that are not normally\
    \ a part of the serialized\ndata but are read in during deserialization.\n\nConsider\
    \ safer alternatives such as serializing data in the JSON format. Ensure any format\n\
    chosen allows\nthe application to specify exactly which object types are allowed\
    \ to be deserialized.\n\nTo protect against mass assignment, only allow deserialization\
    \ of the specific fields that are\nrequired. If this is not easily done, consider\
    \ creating an intermediary type that\ncan be serialized with only the necessary\
    \ fields exposed.\n\nExample JSON deserializer using an intermediary type that\
    \ is validated against a schema to\nensure\nit is safe from mass assignment:\n\
    ```\nimport jsonschema\n\n# Create a schema to validate our user-supplied input\
    \ against\n# an intermediary object\nintermediary_schema = {\n    \"type\" : \"\
    object\",\n    \"properties\" :  {\n        \"name\": {\"type\" : \"string\"}\n\
    \    },\n    \"required\": [\"name\"],\n    # Protect against random properties\
    \ being added to the object\n    \"additionalProperties\": False,\n}\n# If a user\
    \ attempted to add \"'is_admin': True\" it would cause a validation error\nintermediary_object\
    \ = {'name': 'test user'}\n\ntry:\n    # Validate the user supplied intermediary\
    \ object against our schema\n    jsonschema.validate(instance=intermediary_object,\
    \ schema=intermediary_schema)\n    user_object = {'user':\n        {\n       \
    \     # Assign the deserialized data from intermediary object\n            'name':\
    \ intermediary_object['name'],\n            # Add in protected data in object\
    \ definition (or set it from a class constructor)\n            'is_admin': False,\n\
    \        }\n    }\n    # Work with the user_object\nexcept jsonschema.exceptions.ValidationError\
    \ as ex:\n    # Gracefully handle validation errors\n    # ...\n```\n\nFor more\
    \ details on deserialization attacks in general, see OWASP's guide:\n- https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html\n"
  metadata:
    category: security
    cwe: CWE-502
    owasp:
    - A8:2017-Insecure Deserialization
    - A08:2021-Software and Data Integrity Failures
    security-severity: High
    shortDescription: Deserialization of untrusted data
  pattern: cPickle.$FUNC(...)
  severity: WARNING
- id: python_deserialization_rule-marshal
  languages:
  - python
  message: "The application was found using `dill` which is vulnerable to deserialization\
    \ attacks.\nDeserialization attacks exploit the process of reading serialized\
    \ data and turning it back\ninto an object. By constructing malicious objects\
    \ and serializing them, an adversary may\nattempt to:\n\n- Inject code that is\
    \ executed upon object construction, which occurs during the\ndeserialization\
    \ process.\n- Exploit mass assignment by including fields that are not normally\
    \ a part of the serialized\ndata but are read in during deserialization.\n\nConsider\
    \ safer alternatives such as serializing data in the JSON format. Ensure any format\n\
    chosen allows\nthe application to specify exactly which object types are allowed\
    \ to be deserialized.\n\nTo protect against mass assignment, only allow deserialization\
    \ of the specific fields that are\nrequired. If this is not easily done, consider\
    \ creating an intermediary type that\ncan be serialized with only the necessary\
    \ fields exposed.\n\nExample JSON deserializer using an intermediary type that\
    \ is validated against a schema to\nensure\nit is safe from mass assignment:\n\
    ```\nimport jsonschema\n\n# Create a schema to validate our user-supplied input\
    \ against\n# an intermediary object\nintermediary_schema = {\n    \"type\" : \"\
    object\",\n    \"properties\" :  {\n        \"name\": {\"type\" : \"string\"}\n\
    \    },\n    \"required\": [\"name\"],\n    # Protect against random properties\
    \ being added to the object\n    \"additionalProperties\": False,\n}\n# If a user\
    \ attempted to add \"'is_admin': True\" it would cause a validation error\nintermediary_object\
    \ = {'name': 'test user'}\n\ntry:\n    # Validate the user supplied intermediary\
    \ object against our schema\n    jsonschema.validate(instance=intermediary_object,\
    \ schema=intermediary_schema)\n    user_object = {'user':\n        {\n       \
    \     # Assign the deserialized data from intermediary object\n            'name':\
    \ intermediary_object['name'],\n            # Add in protected data in object\
    \ definition (or set it from a class constructor)\n            'is_admin': False,\n\
    \        }\n    }\n    # Work with the user_object\nexcept jsonschema.exceptions.ValidationError\
    \ as ex:\n    # Gracefully handle validation errors\n    # ...\n```\n\nFor more\
    \ details on deserialization attacks in general, see OWASP's guide:\n- https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html\n"
  metadata:
    category: security
    cwe: CWE-502
    owasp:
    - A8:2017-Insecure Deserialization
    - A08:2021-Software and Data Integrity Failures
    security-severity: High
    shortDescription: Deserialization of untrusted data
  pattern-either:
  - pattern: marshal.dump(...)
  - pattern: marshal.dumps(...)
  - pattern: marshal.load(...)
  - pattern: marshal.loads(...)
  severity: WARNING
- id: python_deserialization_rule-dill
  languages:
  - python
  message: "The application was found using `dill` which is vulnerable to deserialization\
    \ attacks.\nDeserialization attacks exploit the process of reading serialized\
    \ data and turning it back\ninto an object. By constructing malicious objects\
    \ and serializing them, an adversary may\nattempt to:\n\n- Inject code that is\
    \ executed upon object construction, which occurs during the\ndeserialization\
    \ process.\n- Exploit mass assignment by including fields that are not normally\
    \ a part of the serialized\ndata but are read in during deserialization.\n\nConsider\
    \ safer alternatives such as serializing data in the JSON format. Ensure any format\n\
    chosen allows\nthe application to specify exactly which object types are allowed\
    \ to be deserialized.\n\nTo protect against mass assignment, only allow deserialization\
    \ of the specific fields that are\nrequired. If this is not easily done, consider\
    \ creating an intermediary type that\ncan be serialized with only the necessary\
    \ fields exposed.\n\nExample JSON deserializer using an intermediary type that\
    \ is validated against a schema to\nensure\nit is safe from mass assignment:\n\
    ```\nimport jsonschema\n\n# Create a schema to validate our user-supplied input\
    \ against\n# an intermediary object\nintermediary_schema = {\n    \"type\" : \"\
    object\",\n    \"properties\" :  {\n        \"name\": {\"type\" : \"string\"}\n\
    \    },\n    \"required\": [\"name\"],\n    # Protect against random properties\
    \ being added to the object\n    \"additionalProperties\": False,\n}\n# If a user\
    \ attempted to add \"'is_admin': True\" it would cause a validation error\nintermediary_object\
    \ = {'name': 'test user'}\n\ntry:\n    # Validate the user supplied intermediary\
    \ object against our schema\n    jsonschema.validate(instance=intermediary_object,\
    \ schema=intermediary_schema)\n    user_object = {'user':\n        {\n       \
    \     # Assign the deserialized data from intermediary object\n            'name':\
    \ intermediary_object['name'],\n            # Add in protected data in object\
    \ definition (or set it from a class constructor)\n            'is_admin': False,\n\
    \        }\n    }\n    # Work with the user_object\nexcept jsonschema.exceptions.ValidationError\
    \ as ex:\n    # Gracefully handle validation errors\n    # ...\n```\n\nFor more\
    \ details on deserialization attacks in general, see OWASP's guide:\n- https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html\n"
  metadata:
    category: security
    cwe: CWE-502
    owasp:
    - A8:2017-Insecure Deserialization
    - A08:2021-Software and Data Integrity Failures
    security-severity: High
    shortDescription: Deserialization of untrusted data
  pattern-either:
  - pattern: dill.$FUNC(...)
  severity: WARNING
- id: python_deserialization_rule-yaml-load
  languages:
  - python
  message: "The application was found using an unsafe version of `yaml` load which\
    \ is vulnerable to\ndeserialization attacks. Deserialization attacks exploit the\
    \ process of reading serialized\ndata and turning it back\ninto an object. By\
    \ constructing malicious objects and serializing them, an adversary may\nattempt\
    \ to:\n\n- Inject code that is executed upon object construction, which occurs\
    \ during the\ndeserialization process.\n- Exploit mass assignment by including\
    \ fields that are not normally a part of the serialized\ndata but are read in\
    \ during deserialization.\n\nTo remediate this issue, use `safe_load()` or call\
    \ `yaml.load()` with the `Loader` argument\nset to\n`yaml.SafeLoader`.\n\nExample\
    \ loading YAML using `safe_load`:\n```\nimport yaml\n\n# Use safe_load to load\
    \ data into an intermediary object\nintermediary_object = yaml.safe_load(\"\"\"\
    user:\n    name: 'test user'\"\"\"\n)\n# Create our real object, copying over\
    \ only the necessary fields\nuser_object = {'user': {\n        # Assign the deserialized\
    \ data from intermediary object\n        'name': intermediary_object['user']['name'],\n\
    \        # Add in protected data in object definition (or set it from a class\
    \ constructor)\n        'is_admin': False,\n    }\n}\n# Work with user_object\n\
    # ...\n```\n\nFor more details on deserialization attacks in general, see OWASP's\
    \ guide:\n- https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html\n"
  metadata:
    category: security
    cwe: CWE-502
    owasp:
    - A8:2017-Insecure Deserialization
    - A08:2021-Software and Data Integrity Failures
    security-severity: High
    shortDescription: Deserialization of untrusted data
  patterns:
  - pattern-inside: 'import yaml

      ...

      '
  - pattern-not-inside: 'from ruamel.yaml import YAML

      ...

      '
  - pattern-either:
    - pattern: yaml.unsafe_load(...)
    - pattern: yaml.$LD(..., Loader=yaml.$LOADER, ...)
    - pattern: yaml.$LD($DATA)
  - metavariable-regex:
      metavariable: $LOADER
      regex: (Loader|UnsafeLoader|CLoader|FullLoader)
  - metavariable-regex:
      metavariable: $LD
      regex: (load|load_all)
  severity: ERROR
- id: python_deserialization_rule-shelve
  languages:
  - python
  message: "The application was found using `shelve` which is vulnerable to deserialization\
    \ attacks as\nit calls `pickle` internally.\nDeserialization attacks exploit the\
    \ process of reading serialized data and turning it back\ninto an object. By constructing\
    \ malicious objects and serializing them, an adversary may\nattempt to:\n\n- Inject\
    \ code that is executed upon object construction, which occurs during the\ndeserialization\
    \ process.\n- Exploit mass assignment by including fields that are not normally\
    \ a part of the serialized\ndata but are read in during deserialization.\n\nConsider\
    \ safer alternatives such as serializing data in the JSON format. Ensure any format\n\
    chosen allows\nthe application to specify exactly which object types are allowed\
    \ to be deserialized.\n\nTo protect against mass assignment, only allow deserialization\
    \ of the specific fields that are\nrequired. If this is not easily done, consider\
    \ creating an intermediary type that\ncan be serialized with only the necessary\
    \ fields exposed.\n\nExample JSON deserializer using an intermediary type that\
    \ is validated against a schema to\nensure\nit is safe from mass assignment:\n\
    ```\nimport jsonschema\n\n# Create a schema to validate our user-supplied input\
    \ against\n# an intermediary object\nintermediary_schema = {\n    \"type\" : \"\
    object\",\n    \"properties\" :  {\n        \"name\": {\"type\" : \"string\"}\n\
    \    },\n    \"required\": [\"name\"],\n    # Protect against random properties\
    \ being added to the object\n    \"additionalProperties\": False,\n}\n# If a user\
    \ attempted to add \"'is_admin': True\" it would cause a validation error\nintermediary_object\
    \ = {'name': 'test user'}\n\ntry:\n    # Validate the user supplied intermediary\
    \ object against our schema\n    jsonschema.validate(instance=intermediary_object,\
    \ schema=intermediary_schema)\n    user_object = {'user':\n        {\n       \
    \     # Assign the deserialized data from intermediary object\n            'name':\
    \ intermediary_object['name'],\n            # Add in protected data in object\
    \ definition (or set it from a class constructor)\n            'is_admin': False,\n\
    \        }\n    }\n    # Work with the user_object\nexcept jsonschema.exceptions.ValidationError\
    \ as ex:\n    # Gracefully handle validation errors\n    # ...\n```\n\nFor more\
    \ details on deserialization attacks in general, see OWASP's guide:\n- https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html\n"
  metadata:
    category: security
    cwe: CWE-502
    owasp:
    - A8:2017-Insecure Deserialization
    - A08:2021-Software and Data Integrity Failures
    security-severity: High
    shortDescription: Deserialization of untrusted data
  pattern-either:
  - pattern: shelve.$FUNC(...)
  severity: WARNING
- id: python_deserialization_rule-pickle
  languages:
  - python
  message: "The application was found using `pickle` which is vulnerable to deserialization\
    \ attacks.\nDeserialization attacks exploit the process of reading serialized\
    \ data and turning it back\ninto an object. By constructing malicious objects\
    \ and serializing them, an adversary may\nattempt to:\n\n- Inject code that is\
    \ executed upon object construction, which occurs during the\ndeserialization\
    \ process.\n- Exploit mass assignment by including fields that are not normally\
    \ a part of the serialized\ndata but are read in during deserialization.\n\nConsider\
    \ safer alternatives such as serializing data in the JSON format. Ensure any format\n\
    chosen allows the application to specify exactly which object types are allowed\
    \ to be deserialized.\n\nTo protect against mass assignment, only allow deserialization\
    \ of the specific fields that are\nrequired. If this is not easily done, consider\
    \ creating an intermediary type that\ncan be serialized with only the necessary\
    \ fields exposed.\n\nExample JSON deserializer using an intermediary type that\
    \ is validated against a schema to ensure\nit is safe from mass assignment:\n\
    ```\nimport jsonschema\n\n# Create a schema to validate our user-supplied input\
    \ against\n# an intermediary object\nintermediary_schema = {\n    \"type\" : \"\
    object\",\n    \"properties\" :  {\n        \"name\": {\"type\" : \"string\"}\n\
    \    },\n    \"required\": [\"name\"],\n    # Protect against random properties\
    \ being added to the object\n    \"additionalProperties\": False,\n}\n# If a user\
    \ attempted to add \"'is_admin': True\" it would cause a validation error\nintermediary_object\
    \ = {'name': 'test user'}\n\ntry:\n    # Validate the user supplied intermediary\
    \ object against our schema\n    jsonschema.validate(instance=intermediary_object,\
    \ schema=intermediary_schema)\n    user_object = {'user':\n        {\n       \
    \     # Assign the deserialized data from intermediary object\n            'name':\
    \ intermediary_object['name'],\n            # Add in protected data in object\
    \ definition (or set it from a class constructor)\n            'is_admin': False,\n\
    \        }\n    }\n    # Work with the user_object\nexcept jsonschema.exceptions.ValidationError\
    \ as ex:\n    # Gracefully handle validation errors\n    # ...\n```\n\nFor more\
    \ details on deserialization attacks in general, see OWASP's guide:\n- https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html\n"
  metadata:
    category: security
    cwe: CWE-502
    owasp:
    - A8:2017-Insecure Deserialization
    - A08:2021-Software and Data Integrity Failures
    security-severity: High
    shortDescription: Deserialization of untrusted data
  patterns:
  - pattern-either:
    - patterns:
      - pattern: pickle.$METHOD(...)
      - pattern-not: pickle.$METHOD("...")
    - patterns:
      - pattern: _pickle.$METHOD(...)
      - pattern-not: _pickle.$METHOD("...")
  - metavariable-regex:
      metavariable: $METHOD
      regex: (load|loads|Unpickler)
  severity: WARNING
- id: python_sql_rule-hardcoded-sql-expression
  languages:
  - python
  message: 'SQL Injection is a critical vulnerability that can lead to data or system
    compromise. By

    dynamically generating SQL query strings, user input may be able to influence
    the logic of

    the SQL statement. This could lead to an adversary accessing information they
    should

    not have access to, or in some circumstances, being able to execute OS functionality
    or code.


    Replace all dynamically generated SQL queries with parameterized queries. In situations
    where

    dynamic queries must be created, never use direct user input, but instead use
    a map or

    dictionary of valid values and resolve them using a user supplied key.


    For example, some database drivers do not allow parameterized queries for `>`
    or `<` comparison

    operators. In these cases, do not use a user supplied `>` or `<` value, but rather
    have the

    user

    supply a `gt` or `lt` value. The alphabetical values are then used to look up
    the `>` and `<`

    values to be used in the construction of the dynamic query. The same goes for
    other queries

    where

    column or table names are required but cannot be parameterized.


    Example using `PreparedStatement` queries:

    ```

    import sqlite3


    # Create a new database (in memory)

    con = sqlite3.connect(":memory:")

    # Get a cursor from the connection

    cur = con.cursor()

    # Create a tuple of the value to be used in the parameterized query

    params = (''user-input'',)

    # execute the statement, passing in the params for the value

    cur.execute("select name from sqlite_master where name = ?", params)

    # work with the result

    result = cur.fetchall()

    ```


    For more information on SQL Injection see OWASP:

    https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html

    '
  metadata:
    category: security
    cwe: CWE-89
    owasp:
    - A1:2017-Injection
    - A03:2021-Injection
    security-severity: High
    shortDescription: Improper neutralization of special elements used in an SQL Command
      ('SQL Injection')
  patterns:
  - metavariable-regex:
      metavariable: $QUERY
      regex: (?i)^(SELECT|INSERT|UPDATE|DELETE)\s
  - pattern-not:
      pattern-either:
      - pattern: $DB.execute("...")
      - pattern: $DB.execute("$QUERY" % "...")
      - pattern: $DB.execute("$QUERY" + "...")
  - pattern-either:
    - pattern: $DB.execute("$QUERY" % ...)
    - pattern: $DB.execute("$QUERY".format(...))
    - pattern: $DB.execute(f"$QUERY")
    - pattern: $DB.execute("$QUERY" + ...)
    - patterns:
      - pattern-either:
        - pattern-inside: '...

            $SQL = "$QUERY" % ...

            ...

            '
        - pattern-inside: '...

            $SQL = "$QUERY" + ...

            ...

            '
        - pattern-inside: '...

            $TMP = "$QUERY"

            ...

            $SQL = $TMP + "..." % ...

            ...

            '
        - pattern-inside: '...

            $SQL = "$QUERY"

            ...

            $SQL += ...

            ...

            '
        - pattern-inside: '...

            $SQL = "$QUERY".format(...)

            ...

            '
        - pattern-inside: '...

            $SQL = f"$QUERY"

            ...

            '
      - pattern: $DB.execute($SQL)
  severity: WARNING
